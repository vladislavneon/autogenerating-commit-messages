mmm a / . idea / libraries / ASM . xml <nl> ppp b / . idea / libraries / ASM . xml <nl>  <nl> < component name = " libraryTable " > <nl> < library name = " ASM " type = " repository " > <nl> - < properties include - transitive - deps = " false " maven - id = " org . jetbrains . intellij . deps : asm - all : 7 . 0 - beta1 " / > <nl> + < properties include - transitive - deps = " false " maven - id = " org . jetbrains . intellij . deps : asm - all : 7 . 0 " / > <nl> < CLASSES > <nl> - < root url = " jar : / / $ MAVEN_REPOSITORY $ / org / jetbrains / intellij / deps / asm - all / 7 . 0 - beta1 / asm - all - 7 . 0 - beta1 . jar ! / " / > <nl> + < root url = " jar : / / $ MAVEN_REPOSITORY $ / org / jetbrains / intellij / deps / asm - all / 7 . 0 / asm - all - 7 . 0 . jar ! / " / > <nl> < / CLASSES > <nl> < JAVADOC / > <nl> < SOURCES > <nl> - < root url = " jar : / / $ MAVEN_REPOSITORY $ / org / jetbrains / intellij / deps / asm - all / 7 . 0 - beta1 / asm - all - 7 . 0 - beta1 - sources . jar ! / " / > <nl> + < root url = " jar : / / $ MAVEN_REPOSITORY $ / org / jetbrains / intellij / deps / asm - all / 7 . 0 / asm - all - 7 . 0 - sources . jar ! / " / > <nl> < / SOURCES > <nl> < / library > <nl> < / component > <nl> \ No newline at end of file <nl> 
mmm a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / GrTypeCalculator . java <nl> ppp b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / GrTypeCalculator . java <nl>  <nl> - / * <nl> - * Copyright 2000 - 2017 JetBrains s . r . o . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> + / / Copyright 2000 - 2018 JetBrains s . r . o . Use of this source code is governed by the Apache 2 . 0 license that can be found in the LICENSE file . <nl> package org . jetbrains . plugins . groovy . lang . typing ; <nl>  <nl> import com . intellij . openapi . util . ClassExtension ; <nl> import com . intellij . psi . PsiType ; <nl> - import org . jetbrains . annotations . ApiStatus . Experimental ; <nl> import org . jetbrains . annotations . NotNull ; <nl> import org . jetbrains . annotations . Nullable ; <nl> import org . jetbrains . plugins . groovy . lang . psi . api . statements . expressions . GrExpression ; <nl> import org . jetbrains . plugins . groovy . lang . psi . api . statements . expressions . GrExpres <nl> / * * <nl> * This API provides ability to plug into expression type calculation in Groovy . <nl> * Each expression has its default implementation which is executed last . <nl> - * < p > <nl> - * The API is experimental at least until 2017 . 3 . <nl> * <nl> * @ param < T > expression class <nl> * @ see DefaultListOrMapTypeCalculator <nl> * @ see DefaultIndexAccessTypeCalculator <nl> * / <nl> - @ Experimental <nl> public interface GrTypeCalculator < T extends GrExpression > { <nl>  <nl> ClassExtension < GrTypeCalculator > EP = new ClassExtension < > ( " org . intellij . groovy . typeCalculator " ) ; <nl> 
mmm a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / psi / typeEnhancers / GrExpressionTypeCalculator . java <nl> ppp b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / psi / typeEnhancers / GrExpressionTypeCalculator . java <nl>  <nl> - / * <nl> - * Copyright 2000 - 2017 JetBrains s . r . o . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> + / / Copyright 2000 - 2018 JetBrains s . r . o . Use of this source code is governed by the Apache 2 . 0 license that can be found in the LICENSE file . <nl> package org . jetbrains . plugins . groovy . lang . psi . typeEnhancers ; <nl>  <nl> import com . intellij . openapi . extensions . ExtensionPointName ; <nl> import com . intellij . psi . PsiElement ; <nl> import com . intellij . psi . PsiType ; <nl> + import org . jetbrains . annotations . ApiStatus . ScheduledForRemoval ; <nl> import org . jetbrains . annotations . NotNull ; <nl> import org . jetbrains . annotations . Nullable ; <nl> import org . jetbrains . plugins . groovy . lang . psi . api . statements . expressions . GrExpression ; <nl>  <nl> / * * <nl> - * @ deprecated To be removed in 2017 . 3 <nl> + * @ deprecated please use { @ link org . jetbrains . plugins . groovy . lang . typing . GrTypeCalculator # EP } <nl> * / <nl> + @ ScheduledForRemoval ( inVersion = " 2019 . 2 " ) <nl> @ Deprecated <nl> + @ SuppressWarnings ( { " DeprecatedIsStillUsed " , " ScheduledForRemoval " } ) <nl> public abstract class GrExpressionTypeCalculator { <nl>  <nl> public static final ExtensionPointName < GrExpressionTypeCalculator > EP_NAME = <nl> diff - - git a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / ReferenceExpressionTypeCalculator . kt b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / ReferenceExpressionTypeCalculator . kt <nl> index b1306c3f6456 . . 3c8cb2148f11 100644 <nl> mmm a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / ReferenceExpressionTypeCalculator . kt <nl> ppp b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / typing / ReferenceExpressionTypeCalculator . kt <nl>  <nl> - / * <nl> - * Copyright 2000 - 2017 JetBrains s . r . o . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - @ file : Suppress ( " DEPRECATION " ) <nl> + / / Copyright 2000 - 2018 JetBrains s . r . o . Use of this source code is governed by the Apache 2 . 0 license that can be found in the LICENSE file . <nl> + @ file : Suppress ( " DEPRECATION " , " ScheduledForRemoval " ) <nl>  <nl> package org . jetbrains . plugins . groovy . lang . typing <nl>  <nl> diff - - git a / plugins / groovy / src / META - INF / plugin . xml b / plugins / groovy / src / META - INF / plugin . xml <nl> index 1a1eb512c000 . . 2ea87cc2c987 100644 <nl> mmm a / plugins / groovy / src / META - INF / plugin . xml <nl> ppp b / plugins / groovy / src / META - INF / plugin . xml <nl>  <nl>  <nl> < extensionPoint name = " callExpressionTypeCalculator " <nl> interface = " org . jetbrains . plugins . groovy . lang . psi . typeEnhancers . GrCallExpressionTypeCalculator " / > <nl> + < ! - - suppress DeprecatedClassUsageInspection - - > <nl> < extensionPoint name = " expressionTypeCalculator " <nl> interface = " org . jetbrains . plugins . groovy . lang . psi . typeEnhancers . GrExpressionTypeCalculator " / > <nl> < extensionPoint name = " typeCalculator " beanClass = " com . intellij . openapi . util . ClassExtensionPoint " > <nl> 
mmm a / platform / platform - impl / src / com / intellij / execution / wsl / WSLDistributionService . java <nl> ppp b / platform / platform - impl / src / com / intellij / execution / wsl / WSLDistributionService . java <nl> class WSLDistributionService implements PersistentStateComponent < WSLDistribution <nl> new WslDistributionDescriptor ( " SLES12 " , " SLES - 12 " , " sles - 12 . exe " , " SUSE Linux Enterprise Server 12 " ) , <nl> new WslDistributionDescriptor ( " UBUNTU " , " Ubuntu " , " ubuntu . exe " , " Ubuntu " ) , <nl> new WslDistributionDescriptor ( " UBUNTU1604 " , " Ubuntu - 16 . 04 " , " ubuntu1604 . exe " , " Ubuntu 16 . 04 " ) , <nl> - new WslDistributionDescriptor ( " UBUNTU1804 " , " Ubuntu - 18 . 04 " , " ubuntu1804 . exe " , " Ubuntu 18 . 04 " ) <nl> + new WslDistributionDescriptor ( " UBUNTU1804 " , " Ubuntu - 18 . 04 " , " ubuntu1804 . exe " , " Ubuntu 18 . 04 " ) , <nl> + new WslDistributionDescriptor ( " WLINUX " , " WLinux " , " wlinux . exe " , " WLinux " ) <nl> ) ; <nl>  <nl> / * * <nl> 
mmm a / json / src / com / jetbrains / jsonSchema / impl / JsonSchemaServiceImpl . java <nl> ppp b / json / src / com / jetbrains / jsonSchema / impl / JsonSchemaServiceImpl . java <nl> public class JsonSchemaServiceImpl implements JsonSchemaService { <nl> if ( ! single ) { <nl> List < VirtualFile > files = ContainerUtil . newArrayList ( ) ; <nl> for ( JsonSchemaFileProvider provider : providers ) { <nl> - VirtualFile schemaFile = provider . getSchemaFile ( ) ; <nl> + VirtualFile schemaFile = getSchemaForProvider ( myProject , provider ) ; <nl> if ( schemaFile ! = null ) { <nl> files . add ( schemaFile ) ; <nl> } <nl> public class JsonSchemaServiceImpl implements JsonSchemaService { <nl> if ( ! userSchema . isPresent ( ) ) return ContainerUtil . emptyList ( ) ; <nl> selected = userSchema . get ( ) ; <nl> } else selected = providers . get ( 0 ) ; <nl> - VirtualFile schemaFile = selected . getSchemaFile ( ) ; <nl> + VirtualFile schemaFile = getSchemaForProvider ( myProject , selected ) ; <nl> return ContainerUtil . createMaybeSingletonList ( schemaFile ) ; <nl> } <nl>  <nl> public class JsonSchemaServiceImpl implements JsonSchemaService { <nl> / / stream API does not allow to collect same keys with Collectors . toMap ( ) : throws duplicate key <nl> final Map < VirtualFile , JsonSchemaFileProvider > map = new THashMap < > ( ) ; <nl> for ( JsonSchemaFileProvider provider : list ) { <nl> - VirtualFile schemaFile = null ; <nl> - if ( JsonSchemaCatalogProjectConfiguration . getInstance ( project ) . isPreferRemoteSchemas ( ) ) { <nl> - final String source = provider . getRemoteSource ( ) ; <nl> - if ( source ! = null & & ! source . endsWith ( " ! " ) ) { <nl> - schemaFile = VirtualFileManager . getInstance ( ) . findFileByUrl ( source ) ; <nl> - } <nl> - } <nl> - if ( schemaFile = = null ) { <nl> - schemaFile = provider . getSchemaFile ( ) ; <nl> - } <nl> + VirtualFile schemaFile = getSchemaForProvider ( project , provider ) ; <nl> if ( schemaFile ! = null ) { <nl> map . put ( schemaFile , provider ) ; <nl> } <nl> public class JsonSchemaServiceImpl implements JsonSchemaService { <nl> return map ; <nl> } <nl> } <nl> + <nl> + @ Nullable <nl> + private static VirtualFile getSchemaForProvider ( @ NotNull Project project , @ NotNull JsonSchemaFileProvider provider ) { <nl> + if ( JsonSchemaCatalogProjectConfiguration . getInstance ( project ) . isPreferRemoteSchemas ( ) ) { <nl> + final String source = provider . getRemoteSource ( ) ; <nl> + if ( source ! = null & & ! source . endsWith ( " ! " ) ) { <nl> + return VirtualFileManager . getInstance ( ) . findFileByUrl ( source ) ; <nl> + } <nl> + } <nl> + return provider . getSchemaFile ( ) ; <nl> + } <nl> } <nl> diff - - git a / json / src / com / jetbrains / jsonSchema / widget / JsonSchemaStatusWidget . java b / json / src / com / jetbrains / jsonSchema / widget / JsonSchemaStatusWidget . java <nl> index 0bd665d91981 . . 5ff023e9e64a 100644 <nl> mmm a / json / src / com / jetbrains / jsonSchema / widget / JsonSchemaStatusWidget . java <nl> ppp b / json / src / com / jetbrains / jsonSchema / widget / JsonSchemaStatusWidget . java <nl> import com . intellij . openapi . vfs . impl . http . HttpVirtualFile ; <nl> import com . intellij . openapi . vfs . impl . http . RemoteFileInfo ; <nl> import com . intellij . openapi . wm . StatusBarWidget ; <nl> import com . intellij . openapi . wm . impl . status . EditorBasedStatusBarPopup ; <nl> + import com . jetbrains . jsonSchema . JsonSchemaCatalogProjectConfiguration ; <nl> import com . jetbrains . jsonSchema . extension . * ; <nl> import com . jetbrains . jsonSchema . ide . JsonSchemaService ; <nl> import com . jetbrains . jsonSchema . impl . JsonSchemaConflictNotificationProvider ; <nl> class JsonSchemaStatusWidget extends EditorBasedStatusBarPopup { <nl>  <nl> JsonSchemaFileProvider provider = myService . getSchemaProvider ( schemaFile ) ; <nl> if ( provider ! = null ) { <nl> - String providerName = provider . getPresentableName ( ) ; <nl> + final boolean preferRemoteSchemas = JsonSchemaCatalogProjectConfiguration . getInstance ( myProject ) . isPreferRemoteSchemas ( ) ; <nl> + final String remoteSource = provider . getRemoteSource ( ) ; <nl> + String providerName = preferRemoteSchemas & & remoteSource ! = null & & ! remoteSource . endsWith ( " ! " ) ? remoteSource : provider . getPresentableName ( ) ; <nl> String shortName = StringUtil . trimEnd ( StringUtil . trimEnd ( providerName , " . json " ) , " - schema " ) ; <nl> - String name = shortName . startsWith ( " JSON schema " ) ? shortName : ( bar + shortName ) ; <nl> - String kind = provider . getSchemaType ( ) = = SchemaType . embeddedSchema | | provider . getSchemaType ( ) = = SchemaType . schema ? " ( bundled ) " : " " ; <nl> + String name = preferRemoteSchemas & & remoteSource ! = null & & ! remoteSource . endsWith ( " ! " ) ? bar + new JsonSchemaInfo ( remoteSource ) . getDescription ( ) <nl> + : ( shortName . startsWith ( " JSON schema " ) ? shortName : ( bar + shortName ) ) ; <nl> + String kind = ! preferRemoteSchemas & & ( provider . getSchemaType ( ) = = SchemaType . embeddedSchema | | provider . getSchemaType ( ) = = SchemaType . schema ) <nl> + ? " ( bundled ) " <nl> + : " " ; <nl> return new MyWidgetState ( tooltip + providerName + kind , name , true ) ; <nl> } <nl>  <nl> 
mmm a / plugins / groovy / groovy - psi / gen / org / jetbrains / plugins / groovy / lang / parser / GroovyGeneratedParser . java <nl> ppp b / plugins / groovy / groovy - psi / gen / org / jetbrains / plugins / groovy / lang / parser / GroovyGeneratedParser . java <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! nextTokenIs ( b , T_LPAREN ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = paren_list ( b , l + 1 , annotation_member_value_pair_parser_ ) ; <nl> + r = paren_list ( b , l + 1 , GroovyGeneratedParser : : annotation_member_value_pair ) ; <nl> exit_section_ ( b , m , ANNOTATION_ARGUMENT_LIST , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < separated_item annotation_array_item_end annotation_value annotation_array_item_start > > <nl> static boolean annotation_array_item ( PsiBuilder b , int l ) { <nl> - return separated_item ( b , l + 1 , annotation_array_item_end_parser_ , annotation_value_parser_ , annotation_array_item_start_parser_ ) ; <nl> + return separated_item ( b , l + 1 , GroovyGeneratedParser : : annotation_array_item_end , GroovyGeneratedParser : : annotation_value , GroovyGeneratedParser : : annotation_array_item_start ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < class_level_item annotation_level > > <nl> static boolean annotation_level_item ( PsiBuilder b , int l ) { <nl> - return class_level_item ( b , l + 1 , annotation_level_parser_ ) ; <nl> + return class_level_item ( b , l + 1 , GroovyGeneratedParser : : annotation_level ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> public static boolean annotation_modifier_list ( PsiBuilder b , int l ) { <nl> if ( ! recursion_guard_ ( b , l , " annotation_modifier_list " ) ) return false ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , MODIFIER_LIST , " < annotation modifier list > " ) ; <nl> - a_b_a ( b , l + 1 , annotation_parser_ , mb_nl_parser_ ) ; <nl> + a_b_a ( b , l + 1 , GroovyGeneratedParser : : annotation , GroovyGeneratedParser : : mb_nl ) ; <nl> exit_section_ ( b , l , m , true , false , null ) ; <nl> return true ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < mb_nl_group ( annotation_method | field_declaration ) > > <nl> static boolean annotation_tails ( PsiBuilder b , int l ) { <nl> - return mb_nl_group ( b , l + 1 , annotation_tails_0_0_parser_ ) ; <nl> + return mb_nl_group ( b , l + 1 , GroovyGeneratedParser : : annotation_tails_0_0 ) ; <nl> } <nl>  <nl> / / annotation_method | field_declaration <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " any_type_element " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , null , " < type > " ) ; <nl> - r = anyTypeElement ( b , l + 1 , type_element_parser_ ) ; <nl> + r = anyTypeElement ( b , l + 1 , GroovyGeneratedParser : : type_element ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = noNewLine ( b , l + 1 ) ; <nl> - r = r & & parseApplication ( b , l + 1 , application_ref_parser_ , application_expression_parser_ , application_call_parser_ , application_index_parser_ ) ; <nl> + r = r & & parseApplication ( b , l + 1 , GroovyGeneratedParser : : application_ref , GroovyGeneratedParser : : application_expression , GroovyGeneratedParser : : application_call , GroovyGeneratedParser : : application_index ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " application_argument_list " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , APPLICATION_ARGUMENT_LIST , " < application argument list > " ) ; <nl> - r = applicationArguments ( b , l + 1 , application_arguments_parser_ ) ; <nl> + r = applicationArguments ( b , l + 1 , GroovyGeneratedParser : : application_arguments ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < argument_list_item_head0 < < brace > > < < argument_list_item_recovery < < brace > > > > > > <nl> static boolean argument_list_item_head ( PsiBuilder b , int l , Parser _brace ) { <nl> - return argument_list_item_head0 ( b , l + 1 , _brace , new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return argument_list_item_recovery ( b , l + 1 , _brace ) ; <nl> - } <nl> - } ) ; <nl> + return argument_list_item_head0 ( b , l + 1 , _brace , argument_list_item_recovery_ $ ( _brace ) ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> + static Parser argument_list_item_recovery_ $ ( Parser _brace ) { <nl> + return ( b , l ) - > argument_list_item_recovery ( b , l + 1 , _brace ) ; <nl> + } <nl> + <nl> / / ! ( < < brace > > | ' , ' | ' } ' | qualified_reference_expression_identifiers | expression_start | argument_label ) <nl> static boolean argument_list_item_recovery ( PsiBuilder b , int l , Parser _brace ) { <nl> if ( ! recursion_guard_ ( b , l , " argument_list_item_recovery " ) ) return false ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> Marker m = enter_section_ ( b , l , _NONE_ ) ; <nl> r = consumeToken ( b , T_LBRACE ) ; <nl> p = r ; / / pin = 1 <nl> - r = r & & report_error_ ( b , a_b_a ( b , l + 1 , array_initializer_item_parser_ , array_initializer_separator_parser_ ) ) ; <nl> + r = r & & report_error_ ( b , a_b_a ( b , l + 1 , GroovyGeneratedParser : : array_initializer_item , GroovyGeneratedParser : : array_initializer_separator ) ) ; <nl> r = p & & report_error_ ( b , array_initializer_pin_2 ( b , l + 1 ) ) & & r ; <nl> r = p & & report_error_ ( b , mb_nl ( b , l + 1 ) ) & & r ; <nl> r = p & & consumeToken ( b , T_RBRACE ) & & r ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < mb_nl_group ( method | variable_declaration_tail ) > > <nl> static boolean block_declaration_tail ( PsiBuilder b , int l ) { <nl> - return mb_nl_group ( b , l + 1 , block_declaration_tail_0_0_parser_ ) ; <nl> + return mb_nl_group ( b , l + 1 , GroovyGeneratedParser : : block_declaration_tail_0_0 ) ; <nl> } <nl>  <nl> / / method | variable_declaration_tail <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = addVariant ( b , l + 1 , " statement " ) ; <nl> - r = r & & separated_item ( b , l + 1 , block_level_end_parser_ , statement_parser_ , block_level_start_parser_ ) ; <nl> + r = r & & separated_item ( b , l + 1 , GroovyGeneratedParser : : block_level_end , GroovyGeneratedParser : : statement , GroovyGeneratedParser : : block_level_start ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = empty_argument_list ( b , l + 1 ) ; <nl> - r = r & & closureArgumentSeparator ( b , l + 1 , call_tail_1_1_0_parser_ ) ; <nl> + r = r & & closureArgumentSeparator ( b , l + 1 , GroovyGeneratedParser : : call_tail_1_1_0 ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " capital_class_type_element " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , null , " < type > " ) ; <nl> - r = capitalizedTypeElement ( b , l + 1 , class_type_element_parser_ , capital_class_type_element_0_1_parser_ ) ; <nl> + r = capitalizedTypeElement ( b , l + 1 , GroovyGeneratedParser : : class_type_element , capital_class_type_element_0_1_parser_ ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = addVariant ( b , l + 1 , " statement " ) ; <nl> - r = r & & separated_item ( b , l + 1 , case_level_end_parser_ , statement_parser_ , case_level_start_parser_ ) ; <nl> + r = r & & separated_item ( b , l + 1 , GroovyGeneratedParser : : case_level_end , GroovyGeneratedParser : : statement , GroovyGeneratedParser : : case_level_start ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> r = case_sections_0 ( b , l + 1 ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & case_sections_1 ( b , l + 1 ) ; <nl> - exit_section_ ( b , l , m , r , p , case_section_recovery_parser_ ) ; <nl> + exit_section_ ( b , l , m , r , p , GroovyGeneratedParser : : case_section_recovery ) ; <nl> return r | | p ; <nl> } <nl>  <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < mb_nl_group ( methods_tail | field_declaration ) > > <nl> static boolean class_declaration_tail ( PsiBuilder b , int l ) { <nl> - return mb_nl_group ( b , l + 1 , class_declaration_tail_0_0_parser_ ) ; <nl> + return mb_nl_group ( b , l + 1 , GroovyGeneratedParser : : class_declaration_tail_0_0 ) ; <nl> } <nl>  <nl> / / methods_tail | field_declaration <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < separated_item class_level_end < < item > > class_level_start > > <nl> static boolean class_level_item ( PsiBuilder b , int l , Parser _item ) { <nl> - return separated_item ( b , l + 1 , class_level_end_parser_ , _item , class_level_start_parser_ ) ; <nl> + return separated_item ( b , l + 1 , GroovyGeneratedParser : : class_level_end , _item , GroovyGeneratedParser : : class_level_start ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < class_level_item class_level > > <nl> static boolean class_member ( PsiBuilder b , int l ) { <nl> - return class_level_item ( b , l + 1 , class_level_parser_ ) ; <nl> + return class_level_item ( b , l + 1 , GroovyGeneratedParser : : class_level ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " closure_parameter_list " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _COLLAPSE_ , PARAMETER_LIST , " < closure parameter list > " ) ; <nl> - r = comma_list ( b , l + 1 , closure_parameter_list_0_0_parser_ ) ; <nl> + r = comma_list ( b , l + 1 , GroovyGeneratedParser : : closure_parameter_list_0_0 ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < codeReferenceIdentifier code_reference_identifiers > > <nl> static boolean code_reference_identifier ( PsiBuilder b , int l ) { <nl> - return codeReferenceIdentifier ( b , l + 1 , code_reference_identifiers_parser_ ) ; <nl> + return codeReferenceIdentifier ( b , l + 1 , GroovyGeneratedParser : : code_reference_identifiers ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < a_b_a < < item > > fast_comma > > <nl> static boolean comma_list ( PsiBuilder b , int l , Parser _item ) { <nl> - return a_b_a ( b , l + 1 , _item , fast_comma_parser_ ) ; <nl> + return a_b_a ( b , l + 1 , _item , GroovyGeneratedParser : : fast_comma ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < a_b_a_p < < item > > fast_comma > > <nl> static boolean comma_list_p ( PsiBuilder b , int l , Parser _item ) { <nl> - return a_b_a_p ( b , l + 1 , _item , fast_comma_parser_ ) ; <nl> + return a_b_a_p ( b , l + 1 , _item , GroovyGeneratedParser : : fast_comma ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> + static Parser d_modifiers_ $ ( Parser _after_modifiers ) { <nl> + return ( b , l ) - > d_modifiers ( b , l + 1 , _after_modifiers ) ; <nl> + } <nl> + <nl> / / non_empty_modifier_list mark_left < < mb_nl_group < < after_modifiers > > > > <nl> static boolean d_modifiers ( PsiBuilder b , int l , Parser _after_modifiers ) { <nl> if ( ! recursion_guard_ ( b , l , " d_modifiers " ) ) return false ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> + static Parser d_no_modifiers_ $ ( Parser _after_no_modifiers ) { <nl> + return ( b , l ) - > d_no_modifiers ( b , l + 1 , _after_no_modifiers ) ; <nl> + } <nl> + <nl> / / empty_modifier_list mark_left < < after_no_modifiers > > <nl> static boolean d_no_modifiers ( PsiBuilder b , int l , Parser _after_no_modifiers ) { <nl> if ( ! recursion_guard_ ( b , l , " d_no_modifiers " ) ) return false ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / / < < d_no_modifiers < < after_no_modifiers > > > > <nl> / / > > <nl> static boolean declaration ( PsiBuilder b , int l , Parser _after_modifiers , Parser _after_no_modifiers ) { <nl> - return choice ( b , l + 1 , new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return d_modifiers ( b , l + 1 , _after_modifiers ) ; <nl> - } <nl> - } , new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return d_no_modifiers ( b , l + 1 , _after_no_modifiers ) ; <nl> - } <nl> - } ) ; <nl> + return choice ( b , l + 1 , d_modifiers_ $ ( _after_modifiers ) , d_no_modifiers_ $ ( _after_no_modifiers ) ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " definitely_type_element " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , null , " < type > " ) ; <nl> - r = definitelyTypeElement ( b , l + 1 , type_element_parser_ , declaration_lookahead_parser_ ) ; <nl> + r = definitelyTypeElement ( b , l + 1 , GroovyGeneratedParser : : type_element , GroovyGeneratedParser : : declaration_lookahead ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < compound_string DOLLAR_SLASHY_BEGIN fast_dollar_slashy_content DOLLAR_SLASHY_END > > <nl> static boolean dollar_slashy_string ( PsiBuilder b , int l ) { <nl> - return compound_string ( b , l + 1 , DOLLAR_SLASHY_BEGIN_parser_ , fast_dollar_slashy_content_parser_ , DOLLAR_SLASHY_END_parser_ ) ; <nl> + return compound_string ( b , l + 1 , DOLLAR_SLASHY_BEGIN_parser_ , GroovyGeneratedParser : : fast_dollar_slashy_content , DOLLAR_SLASHY_END_parser_ ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " expression_or_application " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = notApplicationArguments ( b , l + 1 , expression_or_application_inner_parser_ ) ; <nl> + r = notApplicationArguments ( b , l + 1 , GroovyGeneratedParser : : expression_or_application_inner ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> r = empty ( b , l + 1 ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & noMatch ( b , l + 1 ) ; <nl> - exit_section_ ( b , l , m , r , p , extends_recovery_parser_ ) ; <nl> + exit_section_ ( b , l , m , r , p , GroovyGeneratedParser : : extends_recovery ) ; <nl> return r | | p ; <nl> } <nl>  <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < declaration fvd_after_modifiers fvd_after_no_modifiers > > <nl> static boolean for_variable_declaration ( PsiBuilder b , int l ) { <nl> - return declaration ( b , l + 1 , fvd_after_modifiers_parser_ , fvd_after_no_modifiers_parser_ ) ; <nl> + return declaration ( b , l + 1 , GroovyGeneratedParser : : fvd_after_modifiers , GroovyGeneratedParser : : fvd_after_no_modifiers ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " fvd_modifiers_type " ) ) return false ; <nl> boolean r , p ; <nl> Marker m = enter_section_ ( b , l , _NONE_ ) ; <nl> - r = definitelyTypeElement ( b , l + 1 , type_element_parser_ , variable_lookahead_parser_ ) ; <nl> + r = definitelyTypeElement ( b , l + 1 , GroovyGeneratedParser : : type_element , GroovyGeneratedParser : : variable_lookahead ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & fvd_tail ( b , l + 1 ) ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> r = empty ( b , l + 1 ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & noMatch ( b , l + 1 ) ; <nl> - exit_section_ ( b , l , m , r , p , implements_recovery_parser_ ) ; <nl> + exit_section_ ( b , l , m , r , p , GroovyGeneratedParser : : implements_recovery ) ; <nl> return r | | p ; <nl> } <nl>  <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " lazy_block " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , null , " < lazy block > " ) ; <nl> - r = parseBlockLazy ( b , l + 1 , open_block_parser_ , OPEN_BLOCK ) ; <nl> + r = parseBlockLazy ( b , l + 1 , GroovyGeneratedParser : : open_block , OPEN_BLOCK ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " lazy_constructor_block " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , null , " < lazy constructor block > " ) ; <nl> - r = parseBlockLazy ( b , l + 1 , constructor_block_parser_ , CONSTRUCTOR_BLOCK ) ; <nl> + r = parseBlockLazy ( b , l + 1 , GroovyGeneratedParser : : constructor_block , CONSTRUCTOR_BLOCK ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < parseTailLeftFlat block_declaration_start variable_declaration_tail > > <nl> static boolean local_variable_declaration ( PsiBuilder b , int l ) { <nl> - return parseTailLeftFlat ( b , l + 1 , block_declaration_start_parser_ , variable_declaration_tail_parser_ ) ; <nl> + return parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : block_declaration_start , GroovyGeneratedParser : : variable_declaration_tail ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = _something . parse ( b , l ) ; <nl> - if ( ! r ) r = withProtectedLastVariantPos ( b , l + 1 , new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return mb_nl_group_1_0 ( b , l + 1 , _something ) ; <nl> - } <nl> - } ) ; <nl> + if ( ! r ) r = withProtectedLastVariantPos ( b , l + 1 , mb_nl_group_1_0_ $ ( _something ) ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl>  <nl> + private static Parser mb_nl_group_1_0_ $ ( Parser _something ) { <nl> + return ( b , l ) - > mb_nl_group_1_0 ( b , l + 1 , _something ) ; <nl> + } <nl> + <nl> / / nl < < something > > <nl> private static boolean mb_nl_group_1_0 ( PsiBuilder b , int l , Parser _something ) { <nl> if ( ! recursion_guard_ ( b , l , " mb_nl_group_1_0 " ) ) return false ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! nextTokenIs ( b , T_LPAREN ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = paren_list ( b , l + 1 , parse_parameter_parser_ ) ; <nl> + r = paren_list ( b , l + 1 , GroovyGeneratedParser : : parse_parameter ) ; <nl> exit_section_ ( b , m , PARAMETER_LIST , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = primitive_type_element ( b , l + 1 ) ; <nl> - if ( ! r ) r = allowDiamond ( b , l + 1 , code_reference_parser_ ) ; <nl> + if ( ! r ) r = allowDiamond ( b , l + 1 , GroovyGeneratedParser : : code_reference ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> Marker m = enter_section_ ( b , l , _NONE_ , EXTENDS_CLAUSE , null ) ; <nl> r = consumeTokenFast ( b , KW_EXTENDS ) ; <nl> p = r ; / / pin = 1 <nl> - r = r & & comma_list_p ( b , l + 1 , extends_list_item_parser_ ) ; <nl> + r = r & & comma_list_p ( b , l + 1 , GroovyGeneratedParser : : extends_list_item ) ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> return r | | p ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> Marker m = enter_section_ ( b , l , _NONE_ , IMPLEMENTS_CLAUSE , null ) ; <nl> r = consumeTokenFast ( b , KW_IMPLEMENTS ) ; <nl> p = r ; / / pin = 1 <nl> - r = r & & comma_list_p ( b , l + 1 , implements_list_item_parser_ ) ; <nl> + r = r & & comma_list_p ( b , l + 1 , GroovyGeneratedParser : : implements_list_item ) ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> return r | | p ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " non_empty_modifier_list " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _NONE_ , MODIFIER_LIST , " < non empty modifier list > " ) ; <nl> - r = a_b_a ( b , l + 1 , non_empty_modifier_list_0_0_parser_ , mb_nl_parser_ ) ; <nl> + r = a_b_a ( b , l + 1 , GroovyGeneratedParser : : non_empty_modifier_list_0_0 , GroovyGeneratedParser : : mb_nl ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> Marker m = enter_section_ ( b , l , _NONE_ , THROWS_CLAUSE , null ) ; <nl> r = consumeTokenFast ( b , KW_THROWS ) ; <nl> p = r ; / / pin = 1 <nl> - r = r & & comma_list_p ( b , l + 1 , throws_list_item_parser_ ) ; <nl> + r = r & & comma_list_p ( b , l + 1 , GroovyGeneratedParser : : throws_list_item ) ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> return r | | p ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> Marker m = enter_section_ ( b , l , _NONE_ ) ; <nl> r = consumeTokenFast ( b , T_LT ) ; <nl> p = r ; / / pin = 1 <nl> - r = r & & report_error_ ( b , comma_list_p ( b , l + 1 , type_argument_list_item_parser_ ) ) ; <nl> + r = r & & report_error_ ( b , comma_list_p ( b , l + 1 , GroovyGeneratedParser : : type_argument_list_item ) ) ; <nl> r = p & & type_argument_list_end ( b , l + 1 ) & & r ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> return r | | p ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> r = empty ( b , l + 1 ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & _item . parse ( b , l ) ; <nl> - exit_section_ ( b , l , m , r , p , paren_list_item_recovery_parser_ ) ; <nl> + exit_section_ ( b , l , m , r , p , GroovyGeneratedParser : : paren_list_item_recovery ) ; <nl> return r | | p ; <nl> } <nl>  <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " parse_annotation_declaration " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = parseTailLeftFlat ( b , l + 1 , class_declaration_start_parser_ , annotation_tails_parser_ ) ; <nl> - if ( ! r ) r = parseTailLeftFlat ( b , l + 1 , naked_method_declaration_start_parser_ , annotation_method_parser_ ) ; <nl> + r = parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : class_declaration_start , GroovyGeneratedParser : : annotation_tails ) ; <nl> + if ( ! r ) r = parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : naked_method_declaration_start , GroovyGeneratedParser : : annotation_method ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < parseArgument argument > > <nl> static boolean parse_argument ( PsiBuilder b , int l ) { <nl> - return parseArgument ( b , l + 1 , argument_parser_ ) ; <nl> + return parseArgument ( b , l + 1 , GroovyGeneratedParser : : argument ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < parseTailLeftFlat block_declaration_start block_declaration_tail > > <nl> static boolean parse_block_declaration ( PsiBuilder b , int l ) { <nl> - return parseTailLeftFlat ( b , l + 1 , block_declaration_start_parser_ , block_declaration_tail_parser_ ) ; <nl> + return parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : block_declaration_start , GroovyGeneratedParser : : block_declaration_tail ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < parseTailLeftFlat catch_parameter_start catch_parameter > > <nl> static boolean parse_catch_parameter ( PsiBuilder b , int l ) { <nl> - return parseTailLeftFlat ( b , l + 1 , catch_parameter_start_parser_ , catch_parameter_parser_ ) ; <nl> + return parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : catch_parameter_start , GroovyGeneratedParser : : catch_parameter ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " parse_class_declaration " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = parseTailLeftFlat ( b , l + 1 , class_declaration_start_parser_ , class_declaration_tail_parser_ ) ; <nl> - if ( ! r ) r = parseTailLeftFlat ( b , l + 1 , naked_method_declaration_start_parser_ , methods_tail_parser_ ) ; <nl> + r = parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : class_declaration_start , GroovyGeneratedParser : : class_declaration_tail ) ; <nl> + if ( ! r ) r = parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : naked_method_declaration_start , GroovyGeneratedParser : : methods_tail ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < parseTailLeftFlat parameter_start parameter > > <nl> static boolean parse_parameter ( PsiBuilder b , int l ) { <nl> - return parseTailLeftFlat ( b , l + 1 , parameter_start_parser_ , parameter_parser_ ) ; <nl> + return parseTailLeftFlat ( b , l + 1 , GroovyGeneratedParser : : parameter_start , GroovyGeneratedParser : : parameter ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < qualifiedName code_reference > > <nl> static boolean qualified_name ( PsiBuilder b , int l ) { <nl> - return qualifiedName ( b , l + 1 , code_reference_parser_ ) ; <nl> + return qualifiedName ( b , l + 1 , GroovyGeneratedParser : : code_reference ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " separated_item " ) ) return false ; <nl> boolean r , p ; <nl> Marker m = enter_section_ ( b , l , _NONE_ ) ; <nl> - r = separated_item_head ( b , l + 1 , _item_end , _element , new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return separated_recovery ( b , l + 1 , _element_start , _item_end ) ; <nl> - } <nl> - } ) ; <nl> + r = separated_item_head ( b , l + 1 , _item_end , _element , separated_recovery_ $ ( _element_start , _item_end ) ) ; <nl> p = r ; / / pin = 1 <nl> r = r & & _item_end . parse ( b , l ) ; <nl> exit_section_ ( b , l , m , r , p , null ) ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> + static Parser separated_recovery_ $ ( Parser _item_end , Parser _element_start ) { <nl> + return ( b , l ) - > separated_recovery ( b , l + 1 , _item_end , _element_start ) ; <nl> + } <nl> + <nl> / / ! ( < < item_end > > | < < element_start > > ) <nl> static boolean separated_recovery ( PsiBuilder b , int l , Parser _item_end , Parser _element_start ) { <nl> if ( ! recursion_guard_ ( b , l , " separated_recovery " ) ) return false ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> / / < < compound_string SLASHY_BEGIN fast_slashy_content SLASHY_END > > <nl> static boolean slashy_string ( PsiBuilder b , int l ) { <nl> - return compound_string ( b , l + 1 , SLASHY_BEGIN_parser_ , fast_slashy_content_parser_ , SLASHY_END_parser_ ) ; <nl> + return compound_string ( b , l + 1 , SLASHY_BEGIN_parser_ , GroovyGeneratedParser : : fast_slashy_content , SLASHY_END_parser_ ) ; <nl> } <nl>  <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! r ) r = throw_statement ( b , l + 1 ) ; <nl> if ( ! r ) r = labeled_statement ( b , l + 1 ) ; <nl> if ( ! r ) r = type_definition ( b , l + 1 ) ; <nl> - if ( ! r ) r = withProtectedLastVariantPos ( b , l + 1 , tuple_var_declaration_parser_ ) ; <nl> + if ( ! r ) r = withProtectedLastVariantPos ( b , l + 1 , GroovyGeneratedParser : : tuple_var_declaration ) ; <nl> if ( ! r ) r = parse_block_declaration ( b , l + 1 ) ; <nl> if ( ! r ) r = expression_or_application ( b , l + 1 ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = addVariant ( b , l + 1 , " statement " ) ; <nl> - r = r & & separated_item ( b , l + 1 , top_level_end_parser_ , top_level_parser_ , top_level_start_parser_ ) ; <nl> + r = r & & separated_item ( b , l + 1 , GroovyGeneratedParser : : top_level_end , GroovyGeneratedParser : : top_level , GroovyGeneratedParser : : top_level_start ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = qualified_reference_expression_0_0 ( b , l + 1 ) ; <nl> - r = r & & mb_nl_group ( b , l + 1 , qualified_reference_expression_0_1_0_parser_ ) ; <nl> + r = r & & mb_nl_group ( b , l + 1 , GroovyGeneratedParser : : qualified_reference_expression_0_1_0 ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> r = property_expression_0_0 ( b , l + 1 ) ; <nl> - r = r & & mb_nl_group ( b , l + 1 , property_expression_0_1_0_parser_ ) ; <nl> + r = r & & mb_nl_group ( b , l + 1 , GroovyGeneratedParser : : property_expression_0_1_0 ) ; <nl> exit_section_ ( b , m , null , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! recursion_guard_ ( b , l , " lazy_closure " ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b , l , _COLLAPSE_ , CLOSURE , " < lazy closure > " ) ; <nl> - r = parseBlockLazy ( b , l + 1 , closure_parser_ , CLOSURE ) ; <nl> + r = parseBlockLazy ( b , l + 1 , GroovyGeneratedParser : : closure , CLOSURE ) ; <nl> exit_section_ ( b , l , m , r , false , null ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> if ( ! nextTokenIsSmart ( b , GSTRING_BEGIN ) ) return false ; <nl> boolean r ; <nl> Marker m = enter_section_ ( b ) ; <nl> - r = compound_string ( b , l + 1 , GSTRING_BEGIN_parser_ , fast_string_content_parser_ , GSTRING_END_parser_ ) ; <nl> + r = compound_string ( b , l + 1 , GSTRING_BEGIN_parser_ , GroovyGeneratedParser : : fast_string_content , GSTRING_END_parser_ ) ; <nl> exit_section_ ( b , m , GSTRING , r ) ; <nl> return r ; <nl> } <nl> public class GroovyGeneratedParser implements PsiParser , LightPsiParser { <nl> return r ; <nl> } <nl>  <nl> - final static Parser DOLLAR_SLASHY_BEGIN_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , DOLLAR_SLASHY_BEGIN ) ; <nl> - } <nl> - } ; <nl> - final static Parser DOLLAR_SLASHY_END_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , DOLLAR_SLASHY_END ) ; <nl> - } <nl> - } ; <nl> - final static Parser GSTRING_BEGIN_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , GSTRING_BEGIN ) ; <nl> - } <nl> - } ; <nl> - final static Parser GSTRING_END_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , GSTRING_END ) ; <nl> - } <nl> - } ; <nl> - final static Parser SLASHY_BEGIN_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , SLASHY_BEGIN ) ; <nl> - } <nl> - } ; <nl> - final static Parser SLASHY_END_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , SLASHY_END ) ; <nl> - } <nl> - } ; <nl> - final static Parser T_GT_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , T_GT ) ; <nl> - } <nl> - } ; <nl> - final static Parser T_LBRACE_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeTokenFast ( b , T_LBRACE ) ; <nl> - } <nl> - } ; <nl> - final static Parser T_RBRACK_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , T_RBRACK ) ; <nl> - } <nl> - } ; <nl> - final static Parser T_RPAREN_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return consumeToken ( b , T_RPAREN ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_array_item_end_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_array_item_end ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_array_item_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_array_item_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_level_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_level ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_member_value_pair_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_member_value_pair ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_method_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_method ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_tails_0_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_tails_0_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_tails_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_tails ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser annotation_value_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return annotation_value ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser application_arguments_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return application_arguments ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser application_call_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return application_call ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser application_expression_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return application_expression ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser application_index_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return application_index ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser application_ref_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return application_ref ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser argument_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return argument ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser array_initializer_item_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return array_initializer_item ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser array_initializer_separator_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return array_initializer_separator ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser block_declaration_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return block_declaration_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser block_declaration_tail_0_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return block_declaration_tail_0_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser block_declaration_tail_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return block_declaration_tail ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser block_level_end_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return block_level_end ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser block_level_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return block_level_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser call_tail_1_1_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return call_tail_1_1_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser capital_class_type_element_0_1_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return refWasCapitalized ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser case_level_end_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return case_level_end ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser case_level_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return case_level_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser case_section_recovery_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return case_section_recovery ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser catch_parameter_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return catch_parameter ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser catch_parameter_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return catch_parameter_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_declaration_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_declaration_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_declaration_tail_0_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_declaration_tail_0_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_declaration_tail_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_declaration_tail ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_level_end_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_level_end ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_level_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_level ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_level_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_level_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser class_type_element_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return class_type_element ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser closure_parameter_list_0_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return closure_parameter_list_0_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser closure_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return closure ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser code_reference_identifiers_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return code_reference_identifiers ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser code_reference_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return code_reference ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser constructor_block_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return constructor_block ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser declaration_lookahead_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return declaration_lookahead ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser expression_or_application_inner_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return expression_or_application_inner ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser expression_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return expression ( b , l + 1 , - 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser extends_list_item_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return extends_list_item ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser extends_recovery_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return extends_recovery ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fast_comma_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fast_comma ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fast_dollar_slashy_content_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fast_dollar_slashy_content ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fast_slashy_content_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fast_slashy_content ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fast_string_content_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fast_string_content ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fvd_after_modifiers_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fvd_after_modifiers ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser fvd_after_no_modifiers_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return fvd_after_no_modifiers ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser implements_list_item_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return implements_list_item ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser implements_recovery_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return implements_recovery ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser mb_nl_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return mb_nl ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser methods_tail_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return methods_tail ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser naked_method_declaration_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return naked_method_declaration_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser non_empty_modifier_list_0_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return non_empty_modifier_list_0_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser open_block_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return open_block ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser parameter_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return parameter ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser parameter_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return parameter_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser paren_list_item_recovery_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return paren_list_item_recovery ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser parse_parameter_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return parse_parameter ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser property_expression_0_1_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return property_expression_0_1_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser qualified_reference_expression_0_1_0_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return qualified_reference_expression_0_1_0 ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser statement_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return statement ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser throws_list_item_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return throws_list_item ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser top_level_end_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return top_level_end ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser top_level_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return top_level ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser top_level_start_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return top_level_start ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser tuple_var_declaration_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return tuple_var_declaration ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser type_argument_list_item_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return type_argument_list_item ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser type_element_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return type_element ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser variable_declaration_tail_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return variable_declaration_tail ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> - final static Parser variable_lookahead_parser_ = new Parser ( ) { <nl> - public boolean parse ( PsiBuilder b , int l ) { <nl> - return variable_lookahead ( b , l + 1 ) ; <nl> - } <nl> - } ; <nl> + static final Parser DOLLAR_SLASHY_BEGIN_parser_ = ( b , l ) - > consumeToken ( b , DOLLAR_SLASHY_BEGIN ) ; <nl> + static final Parser DOLLAR_SLASHY_END_parser_ = ( b , l ) - > consumeToken ( b , DOLLAR_SLASHY_END ) ; <nl> + static final Parser GSTRING_BEGIN_parser_ = ( b , l ) - > consumeToken ( b , GSTRING_BEGIN ) ; <nl> + static final Parser GSTRING_END_parser_ = ( b , l ) - > consumeToken ( b , GSTRING_END ) ; <nl> + static final Parser SLASHY_BEGIN_parser_ = ( b , l ) - > consumeToken ( b , SLASHY_BEGIN ) ; <nl> + static final Parser SLASHY_END_parser_ = ( b , l ) - > consumeToken ( b , SLASHY_END ) ; <nl> + static final Parser T_GT_parser_ = ( b , l ) - > consumeToken ( b , T_GT ) ; <nl> + static final Parser T_LBRACE_parser_ = ( b , l ) - > consumeTokenFast ( b , T_LBRACE ) ; <nl> + static final Parser T_RBRACK_parser_ = ( b , l ) - > consumeToken ( b , T_RBRACK ) ; <nl> + static final Parser T_RPAREN_parser_ = ( b , l ) - > consumeToken ( b , T_RPAREN ) ; <nl> + static final Parser capital_class_type_element_0_1_parser_ = ( b , l ) - > refWasCapitalized ( b , l + 1 ) ; <nl> + static final Parser expression_parser_ = ( b , l ) - > expression ( b , l + 1 , - 1 ) ; <nl> } <nl> diff - - git a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / parser / groovy . bnf b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / parser / groovy . bnf <nl> index aab97a257987 . . 88da9033d5dd 100644 <nl> mmm a / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / parser / groovy . bnf <nl> ppp b / plugins / groovy / groovy - psi / src / org / jetbrains / plugins / groovy / lang / parser / groovy . bnf <nl>  <nl> generate = [ <nl> psi = ' no ' <nl> exact - types = ' elements ' <nl> + java = ' 8 ' <nl> ] <nl>  <nl> parserClass = ' org . jetbrains . plugins . groovy . lang . parser . GroovyGeneratedParser ' <nl> 
mmm a / plugins / devkit / devkit - core / resources / org / jetbrains / idea / devkit / DevKitBundle . properties <nl> ppp b / plugins / devkit / devkit - core / resources / org / jetbrains / idea / devkit / DevKitBundle . properties <nl> inspections . plugin . xml . must . not . contain . template . text = Must not contain template <nl> inspections . plugin . xml . value . exceeds . max . length = Value exceeds maximum length { 0 } <nl> inspections . plugin . xml . value . must . have . minimum . length = Value must have minimum length of { 0 } <nl> inspections . plugin . xml . product . descriptor . invalid . date = Date must be in YYYYMMDD format <nl> + inspections . plugin . xml . no . plugin . icon . svg . file = < html > Plugin should provide ' ' { 0 } ' ' ( < a href = " https : / / www . jetbrains . org / intellij / sdk / docs / basics / plugin_structure / plugin_icon_file . html " > Documentation < / a > ) < / html > <nl>  <nl> inspections . registration . problems . name = Component type mismatch <nl> inspections . registration . problems . option . check . plugin . xml = Check Plugin Descriptor ( plugin . xml ) <nl> diff - - git a / plugins / devkit / devkit - core / src / inspections / PluginXmlDomInspection . java b / plugins / devkit / devkit - core / src / inspections / PluginXmlDomInspection . java <nl> index 3101b92708a4 . . 5fa2dea0b16a 100644 <nl> mmm a / plugins / devkit / devkit - core / src / inspections / PluginXmlDomInspection . java <nl> ppp b / plugins / devkit / devkit - core / src / inspections / PluginXmlDomInspection . java <nl> import com . intellij . openapi . vfs . VirtualFile ; <nl> import com . intellij . pom . NavigatableAdapter ; <nl> import com . intellij . psi . * ; <nl> import com . intellij . psi . impl . light . LightMethodBuilder ; <nl> + import com . intellij . psi . search . FilenameIndex ; <nl> + import com . intellij . psi . search . GlobalSearchScope ; <nl> import com . intellij . psi . util . PsiFormatUtil ; <nl> import com . intellij . psi . util . PsiFormatUtilBase ; <nl> import com . intellij . psi . util . PsiTreeUtil ; <nl> import org . jetbrains . jps . model . java . JavaModuleSourceRootTypes ; <nl> import javax . swing . * ; <nl> import java . text . ParseException ; <nl> import java . text . SimpleDateFormat ; <nl> - import java . util . HashSet ; <nl> - import java . util . List ; <nl> - import java . util . Locale ; <nl> - import java . util . Set ; <nl> + import java . util . * ; <nl> import java . util . regex . Matcher ; <nl> import java . util . regex . Pattern ; <nl>  <nl> public class PluginXmlDomInspection extends BasicDomElementsInspection < IdeaPlugin > { <nl> private static final Logger LOG = Logger . getInstance ( PluginXmlDomInspection . class ) ; <nl>  <nl> + @ NonNls <nl> + private static final String PLUGIN_ICON_SVG_FILENAME = " pluginIcon . svg " ; <nl> + <nl> public List < String > myRegistrationCheckIgnoreClassList = new ExternalizableStringSet ( ) ; <nl>  <nl>  <nl> public class PluginXmlDomInspection extends BasicDomElementsInspection < IdeaPlugi <nl> if ( module ! = null ) { <nl> annotateIdeaPlugin ( ( IdeaPlugin ) element , holder , module ) ; <nl> checkJetBrainsPlugin ( ( IdeaPlugin ) element , holder , module ) ; <nl> + checkPluginIcon ( ( IdeaPlugin ) element , holder , module ) ; <nl> } <nl> } <nl> else if ( element instanceof Extension ) { <nl> public class PluginXmlDomInspection extends BasicDomElementsInspection < IdeaPlugi <nl> } <nl> } <nl>  <nl> + private static void checkPluginIcon ( IdeaPlugin ideaPlugin , DomElementAnnotationHolder holder , Module module ) { <nl> + if ( ! hasRealPluginId ( ideaPlugin ) ) return ; <nl> + <nl> + Collection < VirtualFile > pluginIconFiles = <nl> + FilenameIndex . getVirtualFilesByName ( module . getProject ( ) , PLUGIN_ICON_SVG_FILENAME , GlobalSearchScope . moduleScope ( module ) ) ; <nl> + if ( pluginIconFiles . isEmpty ( ) ) { <nl> + holder . createProblem ( ideaPlugin , ProblemHighlightType . WEAK_WARNING , <nl> + DevKitBundle . message ( " inspections . plugin . xml . no . plugin . icon . svg . file " , PLUGIN_ICON_SVG_FILENAME ) , <nl> + null ) ; <nl> + } <nl> + } <nl> + <nl> private static boolean hasRealPluginId ( IdeaPlugin ideaPlugin ) { <nl> String pluginId = ideaPlugin . getPluginId ( ) ; <nl> return pluginId ! = null & & ! pluginId . equals ( PluginManagerCore . CORE_PLUGIN_ID ) ; <nl> diff - - git a / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconFound . xml b / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconFound . xml <nl> new file mode 100644 <nl> index 000000000000 . . 4daebee0e1ff <nl> mmm / dev / null <nl> ppp b / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconFound . xml <nl>  <nl> + < idea - plugin > <nl> + < id > plugin . with . icon < / id > <nl> + < name > Icon was found < / name > <nl> + < vendor > Icons Inc . < / vendor > <nl> + < version > 1 . 0 < / version > <nl> + < / idea - plugin > <nl> \ No newline at end of file <nl> diff - - git a / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconNotFound . xml b / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconNotFound . xml <nl> new file mode 100644 <nl> index 000000000000 . . c9bf66c5175b <nl> mmm / dev / null <nl> ppp b / plugins / devkit / devkit - java - tests / testData / codeInsight / pluginIconNotFound . xml <nl>  <nl> + < < weak_warning descr = " Plugin should provide ' pluginIcon . svg ' ( Documentation ) " > idea - plugin < / weak_warning > > <nl> + < id > plugin . without . icon < / id > <nl> + < name > No Icon < / name > <nl> + < vendor > Icons Inc . < / vendor > <nl> + < version > 1 . 0 < / version > <nl> + < / idea - plugin > <nl> \ No newline at end of file <nl> diff - - git a / plugins / devkit / devkit - java - tests / testSrc / org / jetbrains / idea / devkit / codeInsight / PluginXmlFunctionalTest . groovy b / plugins / devkit / devkit - java - tests / testSrc / org / jetbrains / idea / devkit / codeInsight / PluginXmlFunctionalTest . groovy <nl> index 35d50087bbee . . aacb6f9f9d8f 100644 <nl> mmm a / plugins / devkit / devkit - java - tests / testSrc / org / jetbrains / idea / devkit / codeInsight / PluginXmlFunctionalTest . groovy <nl> ppp b / plugins / devkit / devkit - java - tests / testSrc / org / jetbrains / idea / devkit / codeInsight / PluginXmlFunctionalTest . groovy <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> myFixture . complete ( CompletionType . SMART ) <nl> assertSameElements ( myFixture . lookupElementStrings , [ ' foo . bar . BarAction ' , ' foo . goo . GooAction ' ] ) <nl> assertNull ( toString ( myFixture . lookup . advertisements ) , <nl> - myFixture . lookup . advertisements . find { it . contains ( ' to see inheritors of com . intellij . openapi . actionSystem . AnAction ' ) } ) <nl> + myFixture . lookup . advertisements . find { it . contains ( ' to see inheritors of com . intellij . openapi . actionSystem . AnAction ' ) } ) <nl> } <nl>  <nl> void testExtensionsSpecifyDefaultExtensionNs ( ) { <nl> - myFixture . testHighlighting ( " extensionsSpecifyDefaultExtensionNs . xml " ) <nl> + doHighlightingTest ( " extensionsSpecifyDefaultExtensionNs . xml " ) <nl> } <nl>  <nl> void testDeprecatedExtensionAttribute ( ) { <nl> myFixture . enableInspections ( DeprecatedClassUsageInspection . class ) <nl> - myFixture . testHighlighting ( " deprecatedExtensionAttribute . xml " , " MyExtBean . java " ) <nl> + doHighlightingTest ( " deprecatedExtensionAttribute . xml " , " MyExtBean . java " ) <nl> } <nl>  <nl> void testDeprecatedAttributes ( ) { <nl> - myFixture . testHighlighting ( " deprecatedAttributes . xml " ) <nl> + doHighlightingTest ( " deprecatedAttributes . xml " ) <nl> } <nl>  <nl> void testExtensionAttributeDeclaredUsingAccessors ( ) { <nl> - myFixture . testHighlighting ( " extensionAttributeWithAccessors . xml " , " ExtBeanWithAccessors . java " ) <nl> + doHighlightingTest ( " extensionAttributeWithAccessors . xml " , " ExtBeanWithAccessors . java " ) <nl> } <nl>  <nl> void testExtensionWithInnerTags ( ) { <nl> - myFixture . testHighlighting ( " extensionWithInnerTags . xml " , " ExtBeanWithInnerTags . java " ) <nl> + doHighlightingTest ( " extensionWithInnerTags . xml " , " ExtBeanWithInnerTags . java " ) <nl> } <nl>  <nl> void testLanguageAttributeHighlighting ( ) { <nl> configureLanguageAttributeTest ( ) <nl> - myFixture . testHighlighting ( " languageAttribute . xml " , " MyLanguageAttributeEPBean . java " ) <nl> + doHighlightingTest ( " languageAttribute . xml " , " MyLanguageAttributeEPBean . java " ) <nl> } <nl>  <nl> void testLanguageAttributeCompletion ( ) { <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> " public class MyIcons { " + <nl> " public static final javax . swing . Icon MyCustomIcon = null ; " + <nl> " } " ) <nl> - myFixture . testHighlighting ( " iconAttribute . xml " , <nl> - " MyIconAttributeEPBean . java " ) <nl> + doHighlightingTest ( " iconAttribute . xml " , <nl> + " MyIconAttributeEPBean . java " ) <nl> } <nl>  <nl> void testPluginWithModules ( ) { <nl> - myFixture . testHighlighting ( " pluginWithModules . xml " ) <nl> + doHighlightingTest ( " pluginWithModules . xml " ) <nl> } <nl>  <nl> void testPluginWith99InUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWith99InUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWith99InUntilBuild . xml " ) <nl> } <nl>  <nl> void testPluginWith9999InUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWith9999InUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWith9999InUntilBuild . xml " ) <nl> } <nl>  <nl> void testPluginForOldIdeWith9999InUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginForOldIdeWith9999InUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginForOldIdeWith9999InUntilBuild . xml " ) <nl> } <nl>  <nl> void testPluginWith10000InUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWith10000InUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWith10000InUntilBuild . xml " ) <nl> } <nl>  <nl> void testPluginWithStarInUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWithStarInUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWithStarInUntilBuild . xml " ) <nl> } <nl>  <nl> void testPluginWithBranchNumberInUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWithBranchNumberInUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWithBranchNumberInUntilBuild . xml " ) <nl> } <nl>  <nl> void testReplaceBigNumberInUntilBuildWithStarQuickFix ( ) { <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> } <nl>  <nl> void testPluginWithXInclude ( ) { <nl> - myFixture . testHighlighting ( " pluginWithXInclude . xml " , " pluginWithXInclude - extensionPoints . xml " ) <nl> + doHighlightingTest ( " pluginWithXInclude . xml " , " pluginWithXInclude - extensionPoints . xml " ) <nl> } <nl>  <nl> void testPluginXmlInIdeaProjectWithoutVendor ( ) { <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> } <nl>  <nl> void testOrderAttributeHighlighting ( ) { <nl> - myFixture . testHighlighting ( " orderAttributeHighlighting . xml " ) <nl> + doHighlightingTest ( " orderAttributeHighlighting . xml " ) <nl> } <nl>  <nl> / / separate tests for ' order ' attribute completion because cannot test all cases with completeBasicAllCarets <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> private void testHighlightingInIdeaProject ( String path ) { <nl> PsiUtil . markAsIdeaProject ( project , true ) <nl> try { <nl> - myFixture . testHighlighting ( path ) <nl> + doHighlightingTest ( path ) <nl> } <nl> finally { <nl> PsiUtil . markAsIdeaProject ( project , false ) <nl> class PluginXmlFunctionalTest extends JavaCodeInsightFixtureTestCase { <nl> import com . intellij . openapi . diagnostic . ErrorReportSubmitter ; <nl> public class MyErrorHandler extends ErrorReportSubmitter { } <nl> " " " ) <nl> - myFixture . testHighlighting ( " errorHandlerExtensionInJetBrainsPlugin . xml " ) <nl> + doHighlightingTest ( " errorHandlerExtensionInJetBrainsPlugin . xml " ) <nl> } <nl>  <nl> void testErrorHandlerExtensionInNonJetBrainsPlugin ( ) { <nl> public class MyErrorHandler extends ErrorReportSubmitter { } <nl> import com . intellij . openapi . diagnostic . ErrorReportSubmitter ; <nl> public class MyErrorHandler extends ErrorReportSubmitter { } <nl> " " " ) <nl> - myFixture . testHighlighting ( " errorHandlerExtensionInNonJetBrainsPlugin . xml " ) <nl> + doHighlightingTest ( " errorHandlerExtensionInNonJetBrainsPlugin . xml " ) <nl> } <nl>  <nl> void testExtensionPointPresentation ( ) { <nl> public class MyErrorHandler extends ErrorReportSubmitter { } <nl> } <nl>  <nl> void testExtensionPointNameValidity ( ) { <nl> - myFixture . testHighlighting ( getTestName ( true ) + " . xml " ) <nl> + doHighlightingTest ( getTestName ( true ) + " . xml " ) <nl> } <nl>  <nl> void testExtensionPointValidity ( ) { <nl> - myFixture . testHighlighting ( getTestName ( true ) + " . xml " ) <nl> + doHighlightingTest ( getTestName ( true ) + " . xml " ) <nl> } <nl>  <nl> void testRegistrationCheck ( ) { <nl> public class MyErrorHandler extends ErrorReportSubmitter { } <nl> } <nl>  <nl> void testValuesMaxLengths ( ) { <nl> - myFixture . testHighlighting ( " ValuesMaxLengths . xml " ) <nl> + doHighlightingTest ( " ValuesMaxLengths . xml " ) <nl> } <nl>  <nl> void testValuesRequired ( ) { <nl> - myFixture . testHighlighting ( " ValuesRequired . xml " ) <nl> + doHighlightingTest ( " ValuesRequired . xml " ) <nl> } <nl>  <nl> void testValuesTemplateTexts ( ) { <nl> - myFixture . testHighlighting ( " ValuesTemplateTexts . xml " ) <nl> + doHighlightingTest ( " ValuesTemplateTexts . xml " ) <nl> } <nl>  <nl> void testPluginWithSinceBuildGreaterThanUntilBuild ( ) { <nl> - myFixture . testHighlighting ( " pluginWithSinceBuildGreaterThanUntilBuild . xml " ) <nl> + doHighlightingTest ( " pluginWithSinceBuildGreaterThanUntilBuild . xml " ) <nl> + } <nl> + <nl> + private void doHighlightingTest ( String . . . filePaths ) { <nl> + myFixture . testHighlighting ( true , false , false , filePaths ) <nl> } <nl>  <nl> void testProductDescriptor ( ) { <nl> - myFixture . testHighlighting ( " productDescriptorInvalid . xml " ) <nl> + doHighlightingTest ( " productDescriptorInvalid . xml " ) <nl> } <nl>  <nl> void testProductDescriptorInvalid ( ) { <nl> - myFixture . testHighlighting ( " productDescriptorInvalid . xml " ) <nl> + doHighlightingTest ( " productDescriptorInvalid . xml " ) <nl> + } <nl> + <nl> + void testPluginIconFound ( ) { <nl> + myFixture . addFileToProject ( " pluginIcon . svg " , " fake SVG " ) <nl> + myFixture . testHighlighting ( true , true , true , " pluginIconFound . xml " ) <nl> + } <nl> + <nl> + void testPluginIconNotFound ( ) { <nl> + myFixture . testHighlighting ( true , true , true , " pluginIconNotFound . xml " ) <nl> } <nl> } <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / scenarios / NewProjectDialogModel . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / scenarios / NewProjectDialogModel . kt <nl> fun NewProjectDialogModel . createJavaProject ( projectPath : String , <nl> } <nl> } <nl> button ( buttonNext ) . click ( ) <nl> - logUIStep ( " Fill Project location with ` $ projectPath ` " ) <nl> - textfield ( textProjectName ) . click ( ) <nl> - shortcut ( Key . TAB ) <nl> - shortcut ( Modifier . CONTROL + Key . X , Modifier . META + Key . X ) <nl> - typeText ( projectPath ) <nl> + typeProjectNameAndLocation ( projectPath ) <nl> if ( template . isNotEmpty ( ) & & basePackage . isNotEmpty ( ) ) { <nl> / / base package is set only for Command Line app template <nl> logUIStep ( " Set Base package to ` $ basePackage ` " ) <nl> fun NewProjectDialogModel . createGradleProject ( projectPath : String , gradleOptions <nl> useSeparateModules . click ( ) <nl> } <nl> button ( buttonNext ) . click ( ) <nl> + typeProjectNameAndLocation ( projectPath ) <nl> + logUIStep ( " Close New Project dialog with Finish " ) <nl> + button ( buttonFinish ) . click ( ) <nl> + } <nl> + } <nl> + } <nl> + <nl> + fun NewProjectDialogModel . typeProjectNameAndLocation ( projectPath : String ) { <nl> + with ( guiTestCase ) { <nl> + with ( connectDialog ( ) ) { <nl> logUIStep ( " Fill Project location with ` $ projectPath ` " ) <nl> - / / Field " Project location " is located under additional panel and has location [ 0 , 0 ] , that ' s why we usually click into field " Project name " <nl> - textfield ( textProjectName ) . click ( ) <nl> - shortcut ( Key . TAB ) <nl> + textfield ( textProjectLocation ) . click ( ) <nl> shortcut ( Modifier . CONTROL + Key . X , Modifier . META + Key . X ) <nl> typeText ( projectPath ) <nl> - logUIStep ( " Close New Project dialog with Finish " ) <nl> - button ( buttonFinish ) . click ( ) <nl> + val projectName = projectPath . split ( slash ) . last ( ) <nl> + if ( projectName ! = textfield ( textProjectName ) . text ( ) ) { <nl> + logUIStep ( " Fill Project name with ` $ projectName ` " ) <nl> + textfield ( textProjectName ) . click ( ) <nl> + shortcut ( Modifier . CONTROL + Key . X , Modifier . META + Key . X ) <nl> + typeText ( projectName ) <nl> + } <nl> } <nl> } <nl> } <nl> fun NewProjectDialogModel . createKotlinMPProject ( <nl> jList ( templateName ) . clickItem ( templateName ) <nl> button ( buttonNext ) . click ( ) <nl> button ( buttonNext ) . click ( ) <nl> - logUIStep ( " Fill Project location with ` $ projectPath ` " ) <nl> - textfield ( textProjectLocation ) . click ( ) <nl> - shortcut ( Modifier . CONTROL + Key . X , Modifier . META + Key . X ) <nl> - typeText ( projectPath ) <nl> + typeProjectNameAndLocation ( projectPath ) <nl> logUIStep ( " Close New Project dialog with Finish " ) <nl> button ( buttonFinish ) . click ( ) <nl> } <nl> fun NewProjectDialogModel . createProjectInGroup ( group : NewProjectDialogModel . Grou <nl> selectProjectGroup ( group ) <nl> if ( libs . isSetNotEmpty ( ) ) setLibrariesAndFrameworks ( libs ) <nl> button ( buttonNext ) . click ( ) <nl> - logUIStep ( " Fill Project location with ` $ projectPath ` " ) <nl> - textfield ( textProjectLocation ) . click ( ) <nl> - shortcut ( Modifier . CONTROL + Key . X , Modifier . META + Key . X ) <nl> - typeText ( projectPath ) <nl> + typeProjectNameAndLocation ( projectPath ) <nl> logUIStep ( " Close New Project dialog with Finish " ) <nl> button ( buttonFinish ) . click ( ) <nl> logUIStep ( " Wait when downloading dialog disappears " ) <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / extended / ExtendedJTreePathFixture . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / extended / ExtendedJTreePathFixture . kt <nl> import javax . swing . tree . TreePath <nl> val indentS = " mmm - " <nl> for ( it in 0 until model . getChildCount ( parent ) ) { <nl> val node = model . getChild ( parent , it ) <nl> - println ( " $ { indentS . repeat ( indent ) } $ node " ) <nl> + val value = ExtendedJTreeCellReader ( ) . valueAt ( this , node ) ? . replace ( " \ u200B " , " " ) ? : " " <nl> + println ( " $ { indentS . repeat ( indent ) } $ value " ) <nl> if ( model . isLeaf ( node ) . not ( ) ) <nl> printModel ( node , indent + 1 ) <nl> } <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / CheckboxTreeDriver . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / CheckboxTreeDriver . kt <nl> import java . awt . Container <nl> import java . awt . Point <nl> import java . awt . Rectangle <nl> import javax . swing . JCheckBox <nl> + import javax . swing . JTree <nl> import javax . swing . tree . TreePath <nl>  <nl> class CheckboxTreeDriver ( robot : Robot ) : ExtendedJTreeDriver ( robot ) { <nl> class CheckboxTreeDriver ( robot : Robot ) : ExtendedJTreeDriver ( robot ) { <nl> } <nl>  <nl> fun getCheckboxComponent ( tree : CheckboxTree , path : TreePath ) : JCheckBox ? { <nl> - robot . waitForIdle ( ) <nl> val rendererComponent = tree . cellRenderer . getTreeCellRendererComponent ( tree , path . lastPathComponent , false , false , false , <nl> tree . getRowForPath ( path ) , <nl> false ) <nl> class CheckboxTreeDriver ( robot : Robot ) : ExtendedJTreeDriver ( robot ) { <nl> } <nl>  <nl> private fun CheckboxTree . clickRow ( path : TreePath , calculatePoint : ( Rectangle , Rectangle ) - > Point ) { <nl> - val checkBox = getCheckboxComponent ( this , path ) ? : throw ComponentLookupException ( " Unable to find checkBox for a ExtCheckboxTree with path $ path " ) <nl> + val checkbox = getCheckboxComponent ( this , path ) ? : throw ComponentLookupException ( " Unable to find checkBox for a ExtCheckboxTree with path $ { path . path . joinToString ( ) } " ) <nl> val pathBounds = this . getPathBounds ( path ) <nl> - val point = calculatePoint ( checkBox . bounds , pathBounds ) <nl> + val point = calculatePoint ( checkbox . bounds , pathBounds ) <nl> this . scrollToPath ( path ) <nl> this . makeVisible ( path ) <nl> robot . click ( this , point ) <nl> class CheckboxTreeDriver ( robot : Robot ) : ExtendedJTreeDriver ( robot ) { <nl> } <nl> } <nl>  <nl> - / * * <nl> - * Clicks the label specified by [ path ] <nl> - * out of checkbox area to keep the checkbox value unchanged <nl> - * * / <nl> - fun clickLabel ( tree : CheckboxTree , path : TreePath ) { <nl> - tree . clickRow ( path ) { <nl> - checkboxBounds : Rectangle , pathBounds : Rectangle - > <nl> - Point ( pathBounds . x + checkboxBounds . width + 2 , <nl> - pathBounds . y + checkboxBounds . y + checkboxBounds . height / 2 ) <nl> - } <nl> - } <nl> + override fun getLabelXCoord ( jTree : JTree , path : TreePath ) : Int { <nl> + val checkBox = getCheckboxComponent ( jTree as CheckboxTree , path ) ? : throw ComponentLookupException ( " Unable to find checkBox for a ExtCheckboxTree with path $ path " ) <nl> + val pathBounds = jTree . getPathBounds ( path ) <nl>  <nl> + return pathBounds . x + checkBox . bounds . width + 2 <nl> + } <nl> } <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt <nl> index c706a22daa0d . . ae06e20599dd 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> } <nl> } <nl>  <nl> - private fun JTree . getToggleClickCount ( path : TreePath ) : Int = if ( isInnerExpandControl ( ) ) { <nl> + private fun JTree . refineToggleClickCount ( ) : Int = if ( isInnerExpandControl ( ) ) { <nl> / / expand / collapse symbol is located inside path bounds <nl> / / so the way how to expand / collapse node is controlled by the tree <nl> toggleClickCount <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> } <nl>  <nl> / / to be overridden by CheckboxTree to take into account size of the checkbox control <nl> - protected fun getLabelCoord ( jTree : JTree , path : TreePath ) : Int = jTree . getPathBounds ( path ) . x + 1 <nl> + protected open fun getLabelXCoord ( jTree : JTree , path : TreePath ) : Int = jTree . getPathBounds ( path ) . x + 1 <nl>  <nl> private fun JTree . getScrollBounds ( path : TreePath ) : Rectangle { <nl> val bounds = this . getPathBounds ( path ) <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> val clickY = bounds . y + bounds . height / 2 <nl> return PathInfo ( <nl> expandPoint = Point ( getExpandCoord ( path ) , clickY ) , <nl> - clickPoint = Point ( getLabelCoord ( this , path ) , clickY ) , <nl> - toggleClickCount = getToggleClickCount ( path ) , <nl> + clickPoint = Point ( getLabelXCoord ( this , path ) , clickY ) , <nl> + toggleClickCount = refineToggleClickCount ( ) , <nl> bounds = getScrollBounds ( path ) <nl> ) <nl> } <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / CheckboxTreeFixture . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / CheckboxTreeFixture . kt <nl> index 0112d75a971f . . 80361c6e147f 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / CheckboxTreeFixture . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / fixtures / CheckboxTreeFixture . kt <nl> import com . intellij . testGuiFramework . util . FinderPredicate <nl> import com . intellij . testGuiFramework . fixtures . extended . ExtendedJTreePathFixture <nl> import com . intellij . testGuiFramework . impl . GuiRobotHolder <nl> import com . intellij . testGuiFramework . util . Predicate <nl> + import com . intellij . testGuiFramework . util . currentTimeInHumanString <nl> import com . intellij . ui . CheckboxTree <nl> import org . fest . swing . core . Robot <nl>  <nl> class CheckboxTreeFixture ( <nl>  <nl> fun clickCheckbox ( ) = myDriver . clickCheckbox ( target ( ) as CheckboxTree , path ) <nl>  <nl> - / * * <nl> - * Clicks the label specified by [ path ] <nl> - * out of checkbox area to keep the checkbox value unchanged <nl> - * * / <nl> - fun clickLabel ( ) = myDriver . clickLabel ( target ( ) as CheckboxTree , path ) <nl> + private fun getCheckboxComponent ( ) = myDriver . getCheckboxComponent ( target ( ) as CheckboxTree , path ) <nl>  <nl> - fun getCheckboxComponent ( ) = myDriver . getCheckboxComponent ( target ( ) as CheckboxTree , path ) <nl> - <nl> - fun setCheckboxValue ( value : Boolean ) { <nl> + private fun setCheckboxValue ( value : Boolean ) { <nl> + clickPath ( ) <nl> val checkbox = getCheckboxComponent ( ) <nl> if ( checkbox ! = null & & checkbox . isSelected ! = value ) { <nl> clickCheckbox ( ) <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / generators / Generators . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / generators / Generators . kt <nl> index 9dccc50f562b . . 5ff8beab4997 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / generators / Generators . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / generators / Generators . kt <nl> class CheckboxTreeGenerator : ComponentCodeGenerator < CheckboxTree > { <nl> return if ( wasClickOnCheckBox ( cmp , cp ) ) <nl> " checkboxTree ( $ path ) . clickCheckbox ( ) " <nl> else <nl> - " checkboxTree ( $ path ) . clickLabel ( ) " <nl> + " checkboxTree ( $ path ) . clickPath ( ) " <nl> } <nl> } <nl>  <nl> 
mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt <nl> package com . intellij . ide . projectWizard . kotlin . model <nl>  <nl> import com . intellij . openapi . application . PathManager <nl> import com . intellij . testGuiFramework . fixtures . JDialogFixture <nl> + import com . intellij . testGuiFramework . framework . GuiTestUtil . fileInsertFromBegin <nl> import com . intellij . testGuiFramework . framework . Timeouts . defaultTimeout <nl> import com . intellij . testGuiFramework . framework . GuiTestUtil . fileSearchAndReplace <nl> + import com . intellij . testGuiFramework . framework . GuiTestUtil . isFileContainsLine <nl> import com . intellij . testGuiFramework . impl . * <nl> import com . intellij . testGuiFramework . impl . GuiTestUtilKt . waitUntil <nl> import com . intellij . testGuiFramework . util . * <nl> fun KotlinGuiTestCase . editSettingsGradle ( ) { <nl> / / if project is configured to old Kotlin version , it must be released and no changes are required in the settings . gradle file <nl> if ( ! KotlinTestProperties . isActualKotlinUsed ( ) ) return <nl> val fileName = Paths . get ( projectFolder , " settings . gradle " ) <nl> - if ( KotlinTestProperties . isArtifactOnlyInDevRep ) addDevRepositoryToBuildGradle ( fileName , isKotlinDslUsed = false ) <nl> + if ( KotlinTestProperties . isArtifactOnlyInDevRep ) { <nl> + if ( isFileContainsLine ( fileName , " repositories " ) ) <nl> + addDevRepositoryToBuildGradle ( fileName , isKotlinDslUsed = false ) <nl> + else { <nl> + val pluginManagement = " pluginManagement " <nl> + val repositoriesLines = listOf ( <nl> + " repositories { " , <nl> + " mavenCentral ( ) " , <nl> + " maven { url ' https : / / dl . bintray . com / kotlin / kotlin - dev ' } " , <nl> + " } " <nl> + ) <nl> + <nl> + if ( isFileContainsLine ( fileName , pluginManagement ) ) { <nl> + println ( " editSettingsGradle : file ' $ fileName ' contains ` $ pluginManagement ` " ) <nl> + fileSearchAndReplace ( fileName ) { <nl> + if ( it . contains ( pluginManagement ) ) <nl> + listOf ( it , * repositoriesLines . toTypedArray ( ) ) . joinToString ( separator = " \ n " ) <nl> + else it <nl> + } <nl> + } <nl> + else { <nl> + println ( " editSettingsGradle : file ' $ fileName ' does NOT contain ` $ pluginManagement ` " ) <nl> + fileInsertFromBegin ( fileName , listOf ( <nl> + " pluginManagement { " , <nl> + * repositoriesLines . toTypedArray ( ) , <nl> + " } " <nl> + ) ) <nl> + } <nl> + } <nl> + } <nl> } <nl>  <nl> fun KotlinGuiTestCase . editBuildGradle ( <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / framework / GuiTestUtil . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / framework / GuiTestUtil . kt <nl> index dbbe5ac6945a . . d01519b590ab 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / framework / GuiTestUtil . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / framework / GuiTestUtil . kt <nl> object GuiTestUtil { <nl> } <nl>  <nl> fun fileSearchAndReplace ( fileName : Path , condition : ( String ) - > String ) { <nl> - val buffer = mutableListOf < String > ( ) <nl> - for ( line in Files . readAllLines ( fileName ) ) { <nl> - buffer . add ( condition ( line ) ) <nl> - } <nl> + saveToFile ( <nl> + fileName = fileName , <nl> + linesToSave = Files . readAllLines ( fileName ) . map { condition ( it ) } <nl> + ) <nl> + } <nl> + <nl> + fun isFileContainsLine ( fileName : Path , line : String ) : Boolean { <nl> + return Files . readAllLines ( fileName ) . any { it . contains ( line ) } <nl> + } <nl> + <nl> + fun fileInsertFromBegin ( fileName : Path , lines : List < String > ) { <nl> + saveToFile ( <nl> + fileName = fileName , <nl> + linesToSave = lines + Files . readAllLines ( fileName ) <nl> + ) <nl> + } <nl> + <nl> + private fun saveToFile ( fileName : Path , linesToSave : List < String > ) { <nl> val tmpFile = Files . createTempFile ( fileName . fileName . toString ( ) , " tmp " ) <nl> - Files . write ( tmpFile , buffer ) <nl> + Files . write ( tmpFile , linesToSave ) <nl> Files . copy ( tmpFile , fileName , StandardCopyOption . REPLACE_EXISTING ) <nl> tmpFile . toFile ( ) . deleteOnExit ( ) <nl> } <nl>  <nl> + fun printFileContent ( fileName : Path ) { <nl> + println ( " mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - " ) <nl> + println ( " mmm File : $ fileName mmm " ) <nl> + println ( " mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - " ) <nl> + Files . readAllLines ( fileName ) . forEach { println ( " $ it " ) } <nl> + println ( " mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - " ) <nl> + } <nl> + <nl> fun Long . toMs ( ) : Long = this * 1000 <nl>  <nl> } <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / scenarios / ProjectStructureDialogModel . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / scenarios / ProjectStructureDialogModel . kt <nl>  <nl> package com . intellij . testGuiFramework . util . scenarios <nl>  <nl> import com . intellij . testGuiFramework . fixtures . JDialogFixture <nl> - import com . intellij . testGuiFramework . framework . Timeouts . defaultTimeout <nl> - import com . intellij . testGuiFramework . impl . GuiTestCase <nl> - import com . intellij . testGuiFramework . impl . button <nl> - import com . intellij . testGuiFramework . impl . jList <nl> - import com . intellij . testGuiFramework . impl . testTreeItemExist <nl> + import com . intellij . testGuiFramework . impl . * <nl> import com . intellij . testGuiFramework . util . logUIStep <nl> import com . intellij . testGuiFramework . util . scenarios . ProjectStructureDialogModel . Constants . buttonCancel <nl> import com . intellij . testGuiFramework . util . scenarios . ProjectStructureDialogModel . Constants . itemLibrary <nl> fun ProjectStructureDialogModel . checkLibraryPresent ( vararg library : String ) { <nl> logUIStep ( " Click ' $ menuLibraries ' " ) <nl> tabs . clickItem ( menuLibraries ) <nl> testTreeItemExist ( itemLibrary , * library ) <nl> + jTree ( * library ) . clickPath ( ) <nl> } <nl> } <nl> } <nl> 
mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleKotlinDslProjectWithKotlinGuiTest . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleKotlinDslProjectWithKotlinGuiTest . kt <nl> class CreateGradleKotlinDslProjectWithKotlinGuiTest : KotlinGuiTestCase ( ) { <nl> ) <nl> ) <nl> waitAMoment ( ) <nl> - waitForGradleReimport ( projectName , waitForProject = false ) <nl> + waitForGradleReimport ( projectName ) <nl> editSettingsGradle ( ) <nl> editBuildGradle ( <nl> kotlinVersion = kotlinVersion , <nl> class CreateGradleKotlinDslProjectWithKotlinGuiTest : KotlinGuiTestCase ( ) { <nl> ) <nl> waitAMoment ( ) <nl> gradleReimport ( ) <nl> - waitForGradleReimport ( projectName , waitForProject = true ) <nl> + assert ( waitForGradleReimport ( projectName ) ) { " Gradle import failed after editing of gradle files " } <nl> waitAMoment ( ) <nl>  <nl> projectStructureDialogScenarios . checkGradleExplicitModuleGroups ( <nl> diff - - git a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleProjectWithKotlinGuiTest . kt b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleProjectWithKotlinGuiTest . kt <nl> index 4e825336b095 . . 69dabbab1279 100644 <nl> mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleProjectWithKotlinGuiTest . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateGradleProjectWithKotlinGuiTest . kt <nl> class CreateGradleProjectWithKotlinGuiTest ( private val testParameters : TestParam <nl> projectPath = projectFolder , <nl> gradleOptions = gradleOptions <nl> ) <nl> + val projectName = testMethod . methodName <nl> waitAMoment ( ) <nl> - waitForGradleReimport ( gradleOptions . artifact , waitForProject = false ) <nl> + waitForGradleReimport ( projectName ) <nl> editSettingsGradle ( ) <nl> editBuildGradle ( <nl> kotlinVersion = kotlinVersion , <nl> isKotlinDslUsed = gradleOptions . useKotlinDsl <nl> ) <nl> gradleReimport ( ) <nl> - waitForGradleReimport ( gradleOptions . artifact , waitForProject = true ) <nl> + assert ( waitForGradleReimport ( projectName ) ) { " Gradle import failed after editing of gradle files " } <nl> waitAMoment ( ) <nl>  <nl> projectStructureDialogScenarios . checkGradleExplicitModuleGroups ( <nl> diff - - git a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt <nl> index c01ddd25a420 . . 32a25ef0fd1d 100644 <nl> mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt <nl> class CreateKotlinMPProjectGuiTest ( private val testParameters : TestParameters ) : <nl> ) <nl>  <nl> waitAMoment ( ) <nl> - waitForGradleReimport ( projectName , waitForProject = false ) <nl> + waitForGradleReimport ( projectName ) <nl> editSettingsGradle ( ) <nl> editBuildGradle ( <nl> kotlinVersion = kotlinVersion , <nl> class CreateKotlinMPProjectGuiTest ( private val testParameters : TestParameters ) : <nl> ) <nl>  <nl> gradleReimport ( ) <nl> - waitForGradleReimport ( projectName , waitForProject = true ) <nl> + assert ( waitForGradleReimport ( projectName ) ) { " Gradle import failed after editing of gradle files " } <nl> waitAMoment ( ) <nl>  <nl> projectStructureDialogScenarios . openProjectStructureAndCheck { <nl> diff - - git a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt <nl> index f08386878800 . . a46fff5f5836 100644 <nl> mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / model / ProjectsWithKotlin . kt <nl> fun KotlinGuiTestCase . testCreateGradleAndConfigureKotlin ( <nl> expectedFacet : FacetStructure , <nl> gradleOptions : NewProjectDialogModel . GradleProjectOptions ) { <nl> if ( ! isIdeFrameRun ( ) ) return <nl> + val projectName = testMethod . methodName <nl> createGradleProject ( <nl> projectPath = projectFolder , <nl> gradleOptions = gradleOptions ) <nl> fun KotlinGuiTestCase . testCreateGradleAndConfigureKotlin ( <nl> else - > throw IllegalStateException ( " Cannot configure to Common or Native kind . " ) <nl> } <nl> waitAMoment ( ) <nl> - waitForGradleReimport ( gradleOptions . artifact , waitForProject = false ) <nl> + waitForGradleReimport ( projectName ) <nl> saveAndCloseCurrentEditor ( ) <nl> editSettingsGradle ( ) <nl> editBuildGradle ( <nl> fun KotlinGuiTestCase . testCreateGradleAndConfigureKotlin ( <nl> ) <nl> waitAMoment ( ) <nl> gradleReimport ( ) <nl> - waitForGradleReimport ( gradleOptions . artifact , waitForProject = true ) <nl> + assert ( waitForGradleReimport ( projectName ) ) { " Gradle import failed after editing of gradle files " } <nl> waitAMoment ( ) <nl>  <nl> projectStructureDialogScenarios . checkGradleExplicitModuleGroups ( <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / impl / GuiTestCaseExt . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / impl / GuiTestCaseExt . kt <nl> index 46ef56789db0 . . 5a639c90674c 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / impl / GuiTestCaseExt . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / impl / GuiTestCaseExt . kt <nl> import com . intellij . testGuiFramework . framework . Timeouts <nl> import com . intellij . testGuiFramework . framework . toPrintable <nl> import com . intellij . testGuiFramework . util . * <nl> import org . fest . swing . exception . ComponentLookupException <nl> + import org . fest . swing . exception . LocationUnavailableException <nl> import org . fest . swing . exception . WaitTimedOutError <nl> import org . fest . swing . timing . Condition <nl> import org . fest . swing . timing . Pause <nl> fun ExtendedJTreePathFixture . selectWithKeyboard ( testCase : GuiTestCase , vararg pa <nl> * I detect end of reimport by following signs : <nl> * - action button " Refresh all external projects " becomes enable . But sometimes it becomes <nl> * enable only for a couple of moments and becomes disable again . <nl> - * - the gradle tool window contains the project tree . But if reimporting fails the tree is empty . <nl> + * - status in the first line in the Build tool window becomes ` sync finished ` or ` sync failed ` <nl> * <nl> - * @ param waitForProject true if we expect reimporting successful <nl> - * @ param waitForProject false if we expect reimporting failing and the tree window is expected empty <nl> * @ param rootPath root name expected to be shown in the tree . Checked only if [ waitForProject ] is true <nl> + * @ return status of reimport - true - successful , false - failed <nl> * * / <nl> - fun GuiTestCase . waitForGradleReimport ( rootPath : String , waitForProject : Boolean ) { <nl> - GuiTestUtilKt . waitUntil ( " for gradle reimport finishing " , timeout = Timeouts . minutes05 ) { <nl> - var result = false <nl> + fun GuiTestCase . waitForGradleReimport ( rootPath : String ) : Boolean { <nl> + val syncSuccessful = " sync finished " <nl> + val syncFailed = " sync failed " <nl> + var reimportStatus = " " <nl> + <nl> + GuiTestUtilKt . waitUntil ( " for gradle reimport finishing " , timeout = Timeouts . minutes05 ) { <nl> + var isReimportButtonEnabled : Boolean = false <nl> + var syncState = false <nl> try { <nl> ideFrame { <nl> toolwindow ( id = " Gradle " ) { <nl> content ( tabName = " " ) { <nl> / / first , check whether the action button " Refresh all external projects " is enabled <nl> val text = " Refresh all external projects " <nl> - val isReimportButtonEnabled = try { <nl> + isReimportButtonEnabled = try { <nl> val fixtureByTextAnyState = ActionButtonFixture . fixtureByTextAnyState ( this . target ( ) , robot ( ) , text ) <nl> assertTrue ( " Gradle refresh button should be visible and showing " , this . target ( ) . isShowing & & this . target ( ) . isVisible ) <nl> fixtureByTextAnyState . isEnabled <nl> fun GuiTestCase . waitForGradleReimport ( rootPath : String , waitForProject : Boolean ) <nl> logInfo ( " $ currentTimeInHumanString : waitForGradleReimport . actionButton : $ { e : : class . simpleName } - $ { e . message } " ) <nl> false <nl> } <nl> - / / second , check that Gradle tool window contains a tree with the specified [ rootPath ] <nl> - val gradleWindowHasPath = if ( waitForProject ) { <nl> - try { <nl> - jTree ( rootPath , timeout = Timeouts . noTimeout ) . hasPath ( ) <nl> - } <nl> - catch ( e : Exception ) { <nl> - logInfo ( " $ currentTimeInHumanString : waitForGradleReimport . jTree : $ { e : : class . simpleName } - $ { e . message } " ) <nl> - false <nl> - } <nl> - } <nl> - else true <nl> - / / calculate result whether to continue waiting <nl> - result = gradleWindowHasPath & & isReimportButtonEnabled <nl> } <nl> } <nl> - / / check status in the Build tool window <nl> - var syncState = ! waitForProject <nl> - if ( waitForProject ) { <nl> - toolwindow ( id = " Build " ) { <nl> - content ( tabName = " Sync " ) { <nl> - val tree = treeTable ( ) . target . tree <nl> - val treePath = ExtendedJTreePathFinder ( tree ) . findMatchingPath ( listOf ( this @ ideFrame . project . name + " : " ) ) <nl> - val state = ExtendedJTreeCellReader ( ) . valueAtExtended ( tree , treePath ) ? : " " <nl> - syncState = state . contains ( " sync finished " ) <nl> + / / second , check status in the Build tool window <nl> + toolwindow ( id = " Build " ) { <nl> + content ( tabName = " Sync " ) { <nl> + val tree = treeTable ( ) . target . tree <nl> + val pathStrings = listOf ( rootPath ) <nl> + val treePath = try { <nl> + ExtendedJTreePathFinder ( tree ) . findMatchingPathByPredicate ( pathStrings = pathStrings , predicate = Predicate . startWith ) <nl> + } <nl> + catch ( e : LocationUnavailableException ) { <nl> + null <nl> + } <nl> + if ( treePath ! = null ) { <nl> + reimportStatus = ExtendedJTreeCellReader ( ) . valueAtExtended ( tree , treePath ) ? : " " <nl> + syncState = reimportStatus . contains ( syncSuccessful ) | | reimportStatus . contains ( syncFailed ) <nl> + } <nl> + else { <nl> + syncState = false <nl> } <nl> } <nl> } <nl> - / / final calculating of result <nl> - result = result & & syncState <nl> } <nl> } <nl> catch ( ignore : Exception ) { } <nl> + / / final calculating of result <nl> + val result = isReimportButtonEnabled & & syncState <nl> result <nl> } <nl>  <nl> + return reimportStatus . contains ( syncSuccessful ) <nl> } <nl>  <nl> fun GuiTestCase . gradleReimport ( ) { <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreePathFinder . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreePathFinder . kt <nl> class ExtendedJTreePathFinder ( val jTree : JTree ) { <nl> if ( child is LoadingNode ) <nl> throw ExtendedJTreeDriver . LoadingNodeException ( node = child , treePath = jTree . getPathToNode ( node ) ) <nl> val childValue = jTree . value ( child ) ? : continue <nl> - if ( predicate ( original , childValue ) ) { <nl> + if ( predicate ( childValue , original ) ) { <nl> if ( currentOrder = = order ) { <nl> val newPath = TreePath ( arrayOf < Any > ( * pathTree . path , child ) ) <nl> return if ( pathStrings . size = = 1 ) { <nl> diff - - git a / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / FinderPredicate . kt b / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / FinderPredicate . kt <nl> index 105621ab5322 . . 8e43d03c9133 100644 <nl> mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / FinderPredicate . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / util / FinderPredicate . kt <nl> package com . intellij . testGuiFramework . util <nl> typealias FinderPredicate = ( String , String ) - > Boolean <nl>  <nl> object Predicate { <nl> - val equality : FinderPredicate = { left : String , right : String - > left = = right } <nl> - val notEquality : FinderPredicate = { left : String , right : String - > left ! = right } <nl> - val withVersion : FinderPredicate = { left : String , right : String - > <nl> + val equality : FinderPredicate = { found : String , wanted : String - > found = = wanted } <nl> + val notEquality : FinderPredicate = { found : String , wanted : String - > found ! = wanted } <nl> + val withVersion : FinderPredicate = { found : String , wanted : String - > <nl> val pattern = Regex ( " \ \ s + \ \ ( . * \ \ ) $ " ) <nl> - if ( right . contains ( pattern ) ) <nl> - left = = pattern . split ( right ) . first ( ) . trim ( ) <nl> - else left = = right <nl> + if ( found . contains ( pattern ) ) { <nl> + pattern . split ( found ) . first ( ) . trim ( ) = = wanted <nl> + } <nl> + else found = = wanted <nl> } <nl> - val startWith : FinderPredicate = { left : String , right : String - > left . startsWith ( right ) } <nl> + val startWith : FinderPredicate = { found : String , wanted : String - > found . startsWith ( wanted ) } <nl>  <nl> } <nl> \ No newline at end of file <nl> 
mmm a / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt <nl> ppp b / community - guitests / testSrc / com / intellij / ide / projectWizard / kotlin / createProject / CreateKotlinMPProjectGuiTest . kt <nl>  <nl> package com . intellij . ide . projectWizard . kotlin . createProject <nl>  <nl> import com . intellij . ide . projectWizard . kotlin . model . * <nl> + import com . intellij . testGuiFramework . launcher . system . SystemInfo <nl> import com . intellij . testGuiFramework . framework . param . GuiTestSuiteParam <nl> import com . intellij . testGuiFramework . impl . gradleReimport <nl> import com . intellij . testGuiFramework . impl . waitAMoment <nl> class CreateKotlinMPProjectGuiTest ( private val testParameters : TestParameters ) : <nl> } <nl>  <nl> companion object { <nl> + private val nativeSuffix = when ( SystemInfo . getSystemType ( ) ) { <nl> + SystemInfo . SystemType . WINDOWS - > " mingw " <nl> + SystemInfo . SystemType . UNIX - > " linux " <nl> + SystemInfo . SystemType . MAC - > " macos " <nl> + } <nl> + <nl> private val suffixes = mapOf ( <nl> TargetPlatform . JVM16 to " jvm " , <nl> TargetPlatform . JVM18 to " jvm " , <nl> TargetPlatform . JavaScript to " js " , <nl> TargetPlatform . Common to " common " , <nl> - TargetPlatform . Native to " mingw " <nl> + TargetPlatform . Native to nativeSuffix <nl> ) <nl>  <nl> private val mobileSuffixes = mapOf ( <nl> 
mmm a / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt <nl> ppp b / platform / testGuiFramework / src / com / intellij / testGuiFramework / driver / ExtendedJTreeDriver . kt <nl> import org . fest . swing . exception . WaitTimedOutError <nl> import org . fest . swing . timing . Timeout <nl> import java . awt . Point <nl> import java . awt . Rectangle <nl> - import javax . swing . JPopupMenu <nl> import javax . swing . JTree <nl> import javax . swing . plaf . basic . BasicTreeUI <nl> import javax . swing . tree . TreePath <nl> import javax . swing . tree . TreePath <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDriver ( robot ) { <nl> private val DEFAULT_FIND_PATH_ATTEMPTS : Int = 3 <nl>  <nl> - protected data class PathInfo ( val clickPoint : Point , val toggleClickCount : Int ) <nl> + protected data class PathInfo ( val expandPoint : Point , val clickPoint : Point , val toggleClickCount : Int , val bounds : Rectangle ) <nl>  <nl> init { <nl> val resultReader = when ( javaClass . name ) { <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> button : MouseButton = MouseButton . LEFT_BUTTON , <nl> times : Int = 1 , <nl> attempts : Int = DEFAULT_FIND_PATH_ATTEMPTS ) { <nl> - val point = tree . scrollToPath ( treePath ) <nl> - robot . click ( tree , point , button , times ) <nl> + val pathInfo = tree . scrollToPath ( treePath ) <nl> + robot . click ( tree , pathInfo . clickPoint , button , times ) <nl> / / check that path is selected or click it again <nl> if ( ! tree . checkPathIsSelected ( treePath ) ) { <nl> if ( attempts = = 0 ) <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> } <nl> } <nl>  <nl> - fun JTree . scrollToPath ( path : TreePath ) : Point { <nl> - robot . waitForIdle ( ) <nl> - return this . scrollToMatchingPath ( path ) <nl> - } <nl> - <nl> - private fun JTree . scrollToMatchingPath ( path : TreePath ) : Point { <nl> - this . makeVisible ( path , false ) <nl> - return this . scrollToPathToSelectExt ( path ) <nl> + protected fun JTree . scrollToPath ( path : TreePath ) : PathInfo { <nl> + robot . waitForIdle ( ) <nl> + val result = GuiTestUtilKt . computeOnEdt { <nl> + ComponentPreconditions . checkEnabledAndShowing ( this ) <nl> + val pathInfo = this . getPathInfo ( path ) <nl> + scrollRectToVisible ( pathInfo . bounds ) <nl> + pathInfo <nl> + } ! ! <nl> + robot . waitForIdle ( ) <nl> + return result <nl> } <nl>  <nl> - private fun JTree . scrollToPathToSelectExt ( path : TreePath ) : Point { <nl> - robot . waitForIdle ( ) <nl> - val result = GuiTestUtilKt . computeOnEdt { <nl> - this . scrollToTreePathExt ( path ) <nl> - } ! ! <nl> - robot . waitForIdle ( ) <nl> - return result . clickPoint <nl> - } <nl> + private fun JTree . isInnerExpandControl ( ) : Boolean = this is SimpleTree | | this is TreeTable <nl>  <nl> - private fun JTree . scrollToTreePathExt ( path : TreePath ) : PathInfo { <nl> + private fun JTree . getExpandCoord ( path : TreePath ) : Int { <nl> val bounds = this . getPathBounds ( path ) <nl> - val clickY = bounds . y + bounds . height / 2 <nl> - val boundsWithExpander : Rectangle <nl>  <nl> - val clickInfo = if ( this is SimpleTree | | this is TreeTable ) { <nl> + return if ( isInnerExpandControl ( ) ) { <nl> / / expand / collapse symbol is located inside path bounds <nl> - val clickX = bounds . x + 1 <nl> - boundsWithExpander = bounds <nl> - PathInfo ( Point ( clickX , clickY ) , toggleClickCount ) <nl> + bounds . x + 1 <nl> } <nl> else { <nl> / / in other trees the expand / collapse symbol is located out of the path bounds <nl> / / so we have to expand the bounds to the left <nl> val expandControlRange = TreeUtil . getExpandControlRange ( this , path ) <nl> - val clickX = when { <nl> + when { <nl> expandControlRange ! = null - > expandControlRange . from + ( expandControlRange . to - expandControlRange . from ) / 2 <nl> bounds . x < bounds . height / 2 - > x + 8 <nl> else - > bounds . x - bounds . height / 2 <nl> } <nl> - boundsWithExpander = Rectangle ( expandControlRange ? . from ? : x , bounds . y , bounds . width , bounds . height ) <nl> - PathInfo ( Point ( clickX , clickY ) , toggleClickCount = 1 ) <nl> } <nl> - this . scrollRectToVisible ( boundsWithExpander ) <nl> - return clickInfo <nl> + } <nl> + <nl> + private fun JTree . getToggleClickCount ( path : TreePath ) : Int = if ( isInnerExpandControl ( ) ) { <nl> + / / expand / collapse symbol is located inside path bounds <nl> + / / so the way how to expand / collapse node is controlled by the tree <nl> + toggleClickCount <nl> + } <nl> + else { <nl> + / / in other trees the expand / collapse symbol is located out of the path bounds <nl> + / / we manually expand / collapse the node <nl> + 1 <nl> + } <nl> + <nl> + / / to be overridden by CheckboxTree to take into account size of the checkbox control <nl> + protected fun getLabelCoord ( jTree : JTree , path : TreePath ) : Int = jTree . getPathBounds ( path ) . x + 1 <nl> + <nl> + private fun JTree . getScrollBounds ( path : TreePath ) : Rectangle { <nl> + val bounds = this . getPathBounds ( path ) <nl> + return if ( isInnerExpandControl ( ) ) { <nl> + bounds <nl> + } <nl> + else { <nl> + val expandControlRange = TreeUtil . getExpandControlRange ( this , path ) <nl> + Rectangle ( expandControlRange ? . from ? : x , bounds . y , bounds . width , bounds . height ) <nl> + } <nl> + } <nl> + <nl> + private fun JTree . getPathInfo ( path : TreePath ) : PathInfo { <nl> + val bounds = this . getPathBounds ( path ) <nl> + val clickY = bounds . y + bounds . height / 2 <nl> + return PathInfo ( <nl> + expandPoint = Point ( getExpandCoord ( path ) , clickY ) , <nl> + clickPoint = Point ( getLabelCoord ( this , path ) , clickY ) , <nl> + toggleClickCount = getToggleClickCount ( path ) , <nl> + bounds = getScrollBounds ( path ) <nl> + ) <nl> } <nl>  <nl> private fun JTree . makeVisible ( path : TreePath , expandWhenFound : Boolean ) : Boolean { <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl>  <nl> private fun JTree . waitForChildrenToShowUp ( path : TreePath ) { <nl> try { <nl> - GuiTestUtilKt . waitUntil ( " Waiting for children are shown up " , <nl> + GuiTestUtilKt . waitUntil ( " Waiting for children are shown up " , <nl> Timeout . timeout ( robot . settings ( ) . timeoutToBeVisible ( ) . toLong ( ) ) ) { this . childCount ( path ) ! = 0 } <nl> } <nl> catch ( waitTimedOutError : WaitTimedOutError ) { <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> fun expandPath ( tree : JTree , treePath : TreePath ) { <nl> / / do not try to expand leaf <nl> if ( GuiTestUtilKt . computeOnEdt { tree . model . isLeaf ( treePath . lastPathComponent ) } ! = false ) return <nl> - val info = tree . scrollToMatchingPathAndGetToggleInfo ( treePath ) <nl> - if ( tree . isExpanded ( treePath ) . not ( ) ) tree . toggleCell ( info . clickPoint , info . toggleClickCount ) <nl> + val info = tree . scrollToPath ( treePath ) <nl> + if ( tree . isExpanded ( treePath ) . not ( ) ) tree . toggleCell ( info . expandPoint , info . toggleClickCount ) <nl> } <nl>  <nl> fun collapsePath ( tree : JTree , treePath : TreePath ) { <nl> / / do not try to collapse leaf <nl> if ( GuiTestUtilKt . computeOnEdt { tree . model . isLeaf ( treePath . lastPathComponent ) } ! = false ) return <nl> - val info = tree . scrollToMatchingPathAndGetToggleInfo ( treePath ) <nl> - if ( tree . isExpanded ( treePath ) ) tree . toggleCell ( info . clickPoint , info . toggleClickCount ) <nl> + val info = tree . scrollToPath ( treePath ) <nl> + if ( tree . isExpanded ( treePath ) ) tree . toggleCell ( info . expandPoint , info . toggleClickCount ) <nl> } <nl>  <nl> fun selectPath ( tree : JTree , treePath : TreePath ) { <nl> - tree . selectMatchingPath ( treePath ) <nl> - } <nl> - <nl> - private fun JTree . selectMatchingPath ( path : TreePath ) : Point { <nl> - val pathPoint = scrollToMatchingPath ( path ) <nl> + val pathInfo = tree . scrollToPath ( treePath ) <nl> val isSelected = GuiTestUtilKt . computeOnEdt { <nl> - selectionCount = = 1 & & isPathSelected ( path ) <nl> + tree . selectionCount = = 1 & & tree . isPathSelected ( treePath ) <nl> } ? : false <nl> robot . waitForIdle ( ) <nl> - if ( isSelected . not ( ) ) robot . click ( this , pathPoint ) <nl> - return pathPoint <nl> + if ( isSelected . not ( ) ) robot . click ( tree , pathInfo . clickPoint ) <nl> } <nl>  <nl> private fun JTree . toggleCell ( p : Point , toggleClickCount : Int ) { <nl> open class ExtendedJTreeDriver ( robot : Robot = GuiRobotHolder . robot ) : JTreeDrive <nl> Reflection . method ( " toggleExpandState " ) . withParameterTypes ( TreePath : : class . java ) . ` in ` ( treeUI ) . invoke ( path ) <nl> } <nl>  <nl> - private fun JTree . scrollToMatchingPathAndGetToggleInfo ( treePath : TreePath ) : PathInfo { <nl> - val result = GuiTestUtilKt . computeOnEdt { <nl> - ComponentPreconditions . checkEnabledAndShowing ( this ) <nl> - scrollToTreePathExt ( treePath ) <nl> - } ! ! <nl> - robot . waitForIdle ( ) <nl> - return result <nl> - } <nl> - <nl> - fun showPopupMenu ( tree : JTree , treePath : TreePath ) : JPopupMenu { <nl> - val pathPoint = tree . scrollToMatchingPath ( treePath ) <nl> - robot . waitForIdle ( ) <nl> - return robot . showPopupMenu ( tree , pathPoint ) <nl> - } <nl> - <nl> - fun drag ( tree : JTree , treePath : TreePath ) { <nl> - val p = tree . selectMatchingPath ( treePath ) <nl> - drag ( tree , p ) <nl> - } <nl> - <nl> - fun drop ( tree : JTree , treePath : TreePath ) { <nl> - drop ( tree , tree . scrollToMatchingPath ( treePath ) ) <nl> - } <nl> - <nl> fun findPath ( tree : JTree , stringPath : List < String > , predicate : FinderPredicate = Predicate . equality ) : TreePath { <nl> fun < T > List < T > . list2tree ( ) = map { subList ( 0 , indexOf ( it ) + 1 ) } <nl> lateinit var path : TreePath <nl> 
mmm a / platform / platform - impl / src / com / intellij / ui / EditorTextField . java <nl> ppp b / platform / platform - impl / src / com / intellij / ui / EditorTextField . java <nl> public class EditorTextField extends NonOpaquePanel implements DocumentListener , <nl> return myEditor ; <nl> } <nl>  <nl> + public FileType getFileType ( ) { <nl> + return myFileType ; <nl> + } <nl> + <nl> @ NotNull <nl> public JComponent getFocusTarget ( ) { <nl> return myEditor = = null ? this : myEditor . getContentComponent ( ) ; <nl> diff - - git a / platform / platform - impl / src / com / intellij / ui / ExpandableEditorSupport . java b / platform / platform - impl / src / com / intellij / ui / ExpandableEditorSupport . java <nl> index f55948dcdee3 . . 85748c6b6af1 100644 <nl> mmm a / platform / platform - impl / src / com / intellij / ui / ExpandableEditorSupport . java <nl> ppp b / platform / platform - impl / src / com / intellij / ui / ExpandableEditorSupport . java <nl> public class ExpandableEditorSupport extends ExpandableSupport < EditorTextField > <nl> @ NotNull <nl> @ Override <nl> protected Content prepare ( @ NotNull EditorTextField field , @ NotNull Function < ? super String , String > onShow ) { <nl> - EditorTextField popup = new EditorTextField ( onShow . fun ( field . getText ( ) ) ) ; <nl> + EditorTextField popup = new EditorTextField ( onShow . fun ( field . getText ( ) ) , field . getProject ( ) , field . getFileType ( ) ) ; <nl> Color background = field . getBackground ( ) ; <nl> popup . setBackground ( background ) ; <nl> popup . setOneLineMode ( false ) ; <nl> 
